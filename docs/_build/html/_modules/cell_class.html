

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>cell_class &mdash; Apposed-Cortex Model 1.0 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Apposed-Cortex Model
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"></div>
            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Apposed-Cortex Model</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Module code</a> &raquo;</li>
        
      <li>cell_class</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for cell_class</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># =============================================================================</span>
<span class="c1"># Author  : Alexander Nestor-Bergmann</span>
<span class="c1"># Released: 08/03/2021</span>
<span class="c1"># =============================================================================</span>
<span class="sd">&quot;&quot;&quot;Implementation of a class to represent the cell cortex.&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">colorsys</span>
<span class="kn">import</span> <span class="nn">dill</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">shapely.geometry</span> <span class="k">as</span> <span class="nn">geom</span>

<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib.collections</span> <span class="kn">import</span> <span class="n">LineCollection</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">numpy.core.umath_tests</span> <span class="kn">import</span> <span class="n">inner1d</span>
<span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">solve_bvp</span> <span class="k">as</span> <span class="n">solve_bvp_scipy</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">interp1d</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">decimate</span><span class="p">,</span> <span class="n">resample</span><span class="p">,</span> <span class="n">savgol_filter</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">cKDTree</span>
<span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">NearestNeighbors</span>

<span class="n">matplotlib</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;font.size&#39;</span><span class="p">:</span> <span class="mi">22</span><span class="p">})</span>

<span class="n">CURRENT_DIR</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span>


<div class="viewcode-block" id="Cell"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell">[docs]</a><span class="k">class</span> <span class="nc">Cell</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class that represents the apical cell cortex and holds all variables and functions to manipulate it.</span>

<span class="sd">    The class stores cortex variables ``x``, ``y``, ``theta``, theta&#39; (called ``c``), theta&#39;&#39; (called ``d``) and alpha (called ``gamma``, here).</span>

<span class="sd"> .. note:: Due to old naming conventions, some variables are different to the published names:</span>
<span class="sd">    (name here = published name),</span>
<span class="sd">    ``kappa`` = kappa^2,</span>
<span class="sd">    ``gamma`` = alpha,</span>
<span class="sd">    ``prestrain`` = prestretch,</span>
<span class="sd">    ``s`` = S_0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_guesses</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">param_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">cell_kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialiser to set up the class properties.</span>

<span class="sd">        :param initial_guesses:  A dictionary, with keys [``x``, ``y``, ``theta``, ``c``, ``d``, ``gamma``], of the</span>
<span class="sd">        initial guesses for the cortex variables.</span>
<span class="sd">        :type initial_guesses:  dict</span>
<span class="sd">        :param identifier:  A unique identifier for the cell.</span>
<span class="sd">        :type identifier:  string</span>
<span class="sd">        :param verbose:  Whether to print information on the simulation to the console.</span>
<span class="sd">        :type verbose:  bool</span>
<span class="sd">        :param param_dict:  Dictionary of the mechanical parameters for the cell, ``delta``, ``kappa``, ``omega``.</span>
<span class="sd">        :type param_dict:  dict</span>
<span class="sd">        :param cell_kwargs:  Additional arguments for the cell class (see below).</span>
<span class="sd">        :type cell_kwargs: dict</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Give the cell its unique id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span> <span class="o">=</span> <span class="n">identifier</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Creating cell </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">identifier</span><span class="p">,</span> <span class="nb">object</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1">############ Paramter and cortex variable initialisation</span>

        <span class="c1"># If no params given, set some default ones</span>
        <span class="k">if</span> <span class="n">param_dict</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kappa</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">omega0</span> <span class="o">=</span> <span class="o">.</span><span class="mi">0001</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
        <span class="c1"># Else read.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kappa</span> <span class="o">=</span> <span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;kappa&#39;</span><span class="p">]</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]</span>
            <span class="n">omega0</span> <span class="o">=</span> <span class="n">param_dict</span><span class="p">[</span><span class="s1">&#39;omega0&#39;</span><span class="p">]</span>
        <span class="c1"># Store params:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span> <span class="o">=</span> <span class="n">kappa</span>  <span class="c1"># (is kappa^2 in manuscript)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="o">=</span> <span class="n">delta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omega0</span> <span class="o">=</span> <span class="n">omega0</span>

        <span class="c1"># Initial guesses for cortex variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="n">initial_guesses</span><span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">]</span>  <span class="c1"># D = C&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="n">initial_guesses</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">]</span>  <span class="c1"># C = theta&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">initial_guesses</span><span class="p">[</span><span class="s1">&#39;gamma&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">initial_guesses</span><span class="p">[</span><span class="s1">&#39;theta&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">initial_guesses</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">initial_guesses</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span>

        <span class="c1"># Number of cortex nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">size</span>
        <span class="c1"># If solving requires new nodes to be put in, set the maximum.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decimateAbove</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">*</span> <span class="mf">1.1</span>
        <span class="c1"># Adaptive mesh parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_mesh_coarsen_fraction</span> <span class="o">=</span> <span class="n">cell_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;max_mesh_coarsen_fraction&#39;</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>  <span class="c1"># What proportion of mesh nodes can be removed in a timestep</span>

        <span class="c1">############ Geometry ##############</span>

        <span class="c1"># Cortex rest length set to initial length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rest_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_length</span><span class="p">()</span>
        <span class="c1"># Set the Lagrangian reference, S_0, domain from the current configuration and stretch/prestretch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest_len</span><span class="p">)</span>

        <span class="c1"># Area term: \todo</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">area_stiffness</span> <span class="o">=</span> <span class="n">cell_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;area_stiffness&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pref_area</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_area</span><span class="p">()</span>

        <span class="c1"># S_0 (Lagrangian reference material coord in undeformed configuration)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest_len</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="c1"># Tracking of Lagrangian material points.  Each point is given an identifier, so we can find it when s changes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lagrangian_point_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

        <span class="c1">############ Mechanics ##############</span>

        <span class="c1"># Consitutive model for cortex stress-strain relationship \todo can use only &#39;linear&#39; atm.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">possible_constitutive_models</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="s2">&quot;hyperelastic&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constitutive_model</span> <span class="o">=</span> <span class="n">cell_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;constitutive_model&#39;</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">)</span>

        <span class="c1"># Prestretch applied via &#39;identity sensing&#39; adhesions.  Specify rule for force calculation.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prestrain_type</span> <span class="o">=</span> <span class="n">cell_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;prestrain_type&#39;</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">)</span>  <span class="c1"># Can be &quot;most_common&quot;, &quot;average&quot;, &quot;min&quot;, &quot;nearest&quot;</span>
        <span class="c1"># Dictionary for prestretch (referred to as prestrain)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prestrain_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                               <span class="s1">&#39;I&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;J&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;K&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;N&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;boundary&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
        <span class="c1"># Initialse prestretches to 1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prestrains</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prestrain_indices_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># For identity sensing, how far can the adheions &#39;look&#39; to find other cortices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_search_radius</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">20</span>

        <span class="c1"># Cell pressure forces from medial myosin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pressure</span> <span class="o">=</span> <span class="n">cell_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;pressure&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pressure_on_off</span> <span class="o">=</span> <span class="n">cell_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;pressure_on_off&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>  <span class="c1"># Whether to bother looking for medial pressures. Generally, just use True.</span>

        <span class="c1"># Protrusion forces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">protrusion_target</span> <span class="o">=</span> <span class="n">cell_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;protrusion_target&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># Would be the unique identifier for another cell</span>
        <span class="c1"># And the magnitude of the force</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">protrusion_force</span> <span class="o">=</span> <span class="n">cell_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;protrusion_force&#39;</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>

        <span class="c1"># Tolerance for solving the BVP using Scipy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relax_tol</span> <span class="o">=</span> <span class="n">cell_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;relax_tol&#39;</span><span class="p">,</span> <span class="mf">1e0</span><span class="p">)</span>
        <span class="c1"># Store if solving was successful or not to see if we can trust configuration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_solve_status</span> <span class="o">=</span> <span class="n">cell_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;last_solve_status&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1">############## Adhesion properties ##############</span>

        <span class="c1">##### Fast adhesions</span>

        <span class="c1"># Default off</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fast_adhesions_active</span> <span class="o">=</span> <span class="n">cell_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fast_adhesions_active&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Their constitutive properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_force_law</span> <span class="o">=</span> <span class="n">cell_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;adhesion_force_law&#39;</span><span class="p">,</span> <span class="s1">&#39;spring&#39;</span><span class="p">)</span>  <span class="c1"># Can be &#39;spring&#39; only, for now.</span>
        <span class="c1"># Set a maximum size for adhesions (force=0 for adhesions longer than this)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_adhesion_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">20</span>
        <span class="c1"># How is the force calculated for fast adhesions: can be in [&quot;nearest&quot;, &quot;meanfield&quot;, &quot;fixed_radius&quot;]</span>
        <span class="c1"># &#39;meanfield&#39; is most appropriate for fast adhesions.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_type</span> <span class="o">=</span> <span class="n">cell_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;adhesion_type&#39;</span><span class="p">,</span> <span class="s1">&#39;fixed_radius&#39;</span><span class="p">)</span>
        <span class="c1"># How many adhesions to use in the force calculation. Doesn&#39;t need to be more than 20, smaller is faster.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_num_adhesions_for_force</span> <span class="o">=</span> <span class="n">cell_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;max_num_adhesions_for_force&#39;</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
        <span class="c1"># How forces are scaled based on length of adhesion molecule.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_beta_scale_factor</span> <span class="o">=</span> <span class="n">cell_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;adhesion_beta_scale_factor&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>

        <span class="c1"># Scaling for omega to modulute adhesion density on certain junctions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_density_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
                                      <span class="s1">&#39;I&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;J&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;K&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;N&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;boundary&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                                      <span class="s1">&#39;none&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>

        <span class="c1"># This is where information about nearby cortices (within adhesion_search_radius) is held, which is what fast</span>
        <span class="c1"># adhesions could possibly couple to.   The information is passed from the eptm class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_point_coords</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># (x,y) coords of nearby neighbouring cells</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_point_identifiers</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># identifier of cell for the (x,y) coords above.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_point_spacings</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Cortex spacing (in current configuration) of neighbouring nodes</span>

        <span class="c1"># Containers for the actual adhesion connections that are made. Each idx represents the data for the cortex</span>
        <span class="c1"># idx. So self.adhesion_distances[idx] gives the lengths of the adhesion bonds at self.s[idx]</span>
        <span class="c1"># We store this information so it doesn&#39;t need to be calculated on the fly</span>
        <span class="c1"># Total force from adhesion at every node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_forces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="c1"># Lengths of adhesion connections that have been made.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_distances</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># The (x,y) coords of connections from self.adhesion_point_coords that are actually made.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># The ids of the connections</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections_identities</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># A list of the cells that each node is connected to (the unique list of all connections)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections_identities_unique</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Spacings of the connections that were made.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections_spacings</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1">########### SDK and slow adhesions.</span>

        <span class="c1"># We need to keep these lists around when saving.  The lists are populated Adhesion class objects, which</span>
        <span class="c1"># contain information about which cortex nodes are connected to where.</span>

        <span class="c1"># Sidekick (vertex-specific)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sidekick_adhesions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sdk_stiffness</span> <span class="o">=</span> <span class="n">cell_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;sdk_stiffness&#39;</span><span class="p">,</span> <span class="mi">100</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sdk_restlen</span> <span class="o">=</span> <span class="n">cell_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;sdk_restlen&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Slow adhesions (when tau_ad &gt;= 1).  Need to keep a perma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slow_adhesions</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1">############## Misc ##############</span>

        <span class="c1"># How close to plot prestrain next to cortex</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prestrain_plot_offset</span> <span class="o">=</span> <span class="n">cell_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;prestrain_plot_offset&#39;</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">)</span>


<div class="viewcode-block" id="Cell.verboseprint"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.verboseprint">[docs]</a>    <span class="k">def</span> <span class="nf">verboseprint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Function to print out details as code runs</span>

<span class="sd">        :param args:  Information to be printed to console.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="k">else</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Cell.prune_adhesion_data"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.prune_adhesion_data">[docs]</a>    <span class="k">def</span> <span class="nf">prune_adhesion_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Remove all locally stored adhesion data.  This data is usually permanently held by the Epithelium class.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_point_coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_point_identifiers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_point_spacings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_forces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_distances</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections_identities</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections_identities_unique</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections_spacings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sidekick_adhesions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slow_adhesions</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">prestrains</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_tree</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_polygon</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Cell.update_reference_configuration_to_current"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.update_reference_configuration_to_current">[docs]</a>    <span class="k">def</span> <span class="nf">update_reference_configuration_to_current</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update the Lagrangian coordinate S_0 to the current configuration from the stretches and prestretches:</span>
<span class="sd">         S_0 &lt;- s = S_0 * stretch * prestretch</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Calculate the prestretches</span>
        <span class="n">prestrains</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_prestrains</span><span class="p">()</span>
        <span class="c1"># Current undeformed segment lengths</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">)</span>
        <span class="c1"># Update S_0</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">prestrains</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">ds</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="c1"># Reset the rest length and integration domain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rest_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># self.get_mesh_spacing()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_deformed_mesh_spacing</span><span class="p">()</span></div>


<div class="viewcode-block" id="Cell.update_adhesion_points"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.update_adhesion_points">[docs]</a>    <span class="k">def</span> <span class="nf">update_adhesion_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">spacing</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Store points that fast adhesions can adhere to.</span>

<span class="sd">        :param points:  A list of (x,y) coordinates, which the cell cortex xan adhere to.</span>
<span class="sd">        :type points: list</span>
<span class="sd">        :param ids:  A list of the cell identifiers that those adhesion points came from.</span>
<span class="sd">        :type ids:  list</span>
<span class="sd">        :param spacing:  A list of the discretised spacing (on the other cortices) for those adhesion points.</span>
<span class="sd">        :type spacing: list</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Store the nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_point_coords</span> <span class="o">=</span> <span class="n">points</span>

        <span class="c1"># Store these identifiers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_point_identifiers</span> <span class="o">=</span> <span class="n">ids</span>

        <span class="c1"># Store the spacings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_point_spacings</span> <span class="o">=</span> <span class="n">spacing</span></div>


<div class="viewcode-block" id="Cell.clear_adhesion_points"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.clear_adhesion_points">[docs]</a>    <span class="k">def</span> <span class="nf">clear_adhesion_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove all stored possible adhesion points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_point_coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_point_identifiers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_point_spacings</span> <span class="o">=</span> <span class="p">[]</span></div>


<div class="viewcode-block" id="Cell.get_neighbours"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.get_neighbours">[docs]</a>    <span class="k">def</span> <span class="nf">get_neighbours</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the identities of neighbouring cells</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">neighbours</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">neighbours</span><span class="p">)</span></div>


<div class="viewcode-block" id="Cell.get_intersection_indices"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.get_intersection_indices">[docs]</a>    <span class="k">def</span> <span class="nf">get_intersection_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get at list of the idxs, from given points, that intersect adhesion boundaries. DEPRECIATED</span>

<span class="sd">        :param points:  The coords of points to check</span>
<span class="sd">        :type points: list</span>
<span class="sd">        :return indices: The indices of the points that intersected the boundary.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Build the boundary polygon, if it doesn&#39;t exist</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_polygon</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">build_adhesion_tree</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">intersect_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_polygon</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">points</span><span class="p">))</span>
            <span class="n">intersect_points_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">(</span><span class="n">intersect_points</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>

            <span class="k">return</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">))</span> <span class="k">if</span>
                    <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_polygon</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))]</span>

        <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">intersect_points_coords</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">indices</span></div>


<div class="viewcode-block" id="Cell.check_if_cell_intersects_adhesion_boundary"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.check_if_cell_intersects_adhesion_boundary">[docs]</a>    <span class="k">def</span> <span class="nf">check_if_cell_intersects_adhesion_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if any cortex node intersects the adhesion boundary</span>

<span class="sd">        :param x:  (Default value = None) x coords for cell cortex points.  Can default to use stored values.</span>
<span class="sd">        :type x:  list</span>
<span class="sd">        :param y:  (Default value = None) y coords for cell cortex points.  Can default to use stored values.</span>
<span class="sd">        :type y:  list</span>
<span class="sd">        :return: If the boundary intersects.</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_polygon</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">build_adhesion_tree</span><span class="p">(</span><span class="n">build_polygon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Build the polygon and check for intersections</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_polygon</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)))</span></div>


<div class="viewcode-block" id="Cell.move_cortex_nodes_to_equilibrium_dist"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.move_cortex_nodes_to_equilibrium_dist">[docs]</a>    <span class="k">def</span> <span class="nf">move_cortex_nodes_to_equilibrium_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">neighbours_moving</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Enforces that the cortex is no closer than delta to any neighbouring cortex</span>

<span class="sd">        :param scaling:  (Default value = 1)  Additional scaling relative to delta that the cortex nodes will sit from neighbours.</span>
<span class="sd">        :type scaling:  float</span>
<span class="sd">        :param neighbours_moving:  (Default value = True)  An additional check if the neighbouring cortices will move.</span>
<span class="sd">        :type neighbours_moving:  bool</span>
<span class="sd">        :return: Wether we were successful.</span>
<span class="sd">        :rtype: bool</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Cortex nodes</span>
        <span class="n">cortex_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Indices of nearest adhesions</span>
        <span class="n">min_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">ads</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ads</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">ads</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_distances</span><span class="p">])</span>

        <span class="c1"># Get indices of short distances</span>
        <span class="n">too_close_indices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">adhesion_distances</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">min_idxs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="k">if</span> <span class="n">min_idxs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">False</span>
                             <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">min_idxs</span><span class="p">))]</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">too_close_indices</span><span class="p">):</span>
            <span class="c1"># Vectors from adhesion</span>
            <span class="n">adhesion_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">min_idxs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                                       <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">too_close_indices</span><span class="p">))</span> <span class="k">if</span> <span class="n">too_close_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

            <span class="c1"># Get the distances</span>
            <span class="n">adhesion_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">adhesion_distances</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">min_idxs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                                           <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">too_close_indices</span><span class="p">))</span> <span class="k">if</span> <span class="n">too_close_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

            <span class="c1"># Sliced cortex nodes</span>
            <span class="n">cortex_nodes</span> <span class="o">=</span> <span class="n">cortex_nodes</span><span class="p">[</span><span class="n">too_close_indices</span><span class="p">]</span>

            <span class="c1"># vec to New positions</span>
            <span class="n">shift_from_adhesions</span> <span class="o">=</span> <span class="n">cortex_nodes</span> <span class="o">-</span> <span class="n">adhesion_nodes</span>
            <span class="c1"># shift_from_adhesions /= np.sqrt((shift_from_adhesions ** 2).sum(-1))[..., np.newaxis]</span>
            <span class="n">shift_from_adhesions</span> <span class="o">/=</span> <span class="n">adhesion_distances</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="n">shift_from_adhesions</span> <span class="o">*=</span> <span class="n">scaling</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span>

            <span class="k">if</span> <span class="n">neighbours_moving</span><span class="p">:</span>
                <span class="c1"># Get the identities</span>
                <span class="n">adhesion_nodes_connections</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">min_idxs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                                                       <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">min_idxs</span><span class="p">))</span> <span class="k">if</span> <span class="n">too_close_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

                <span class="c1"># Nodes not neighbouring boundary move only half each (because other cell will also move)</span>
                <span class="n">adhesion_distances_sliced</span> <span class="o">=</span> <span class="n">adhesion_distances</span><span class="p">[</span><span class="n">adhesion_nodes_connections</span> <span class="o">!=</span> <span class="s1">&#39;boundary&#39;</span><span class="p">]</span>
                <span class="n">shift_from_adhesions</span><span class="p">[</span><span class="n">adhesion_nodes_connections</span> <span class="o">!=</span> <span class="s1">&#39;boundary&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span>
                            <span class="n">adhesion_distances_sliced</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">too_close_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">adhesion_nodes</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">shift_from_adhesions</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">too_close_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">adhesion_nodes</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">shift_from_adhesions</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="Cell.scale_whole_cell_to_fit_adhesion_to_delta"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.scale_whole_cell_to_fit_adhesion_to_delta">[docs]</a>    <span class="k">def</span> <span class="nf">scale_whole_cell_to_fit_adhesion_to_delta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stretch_factor</span><span class="o">=</span><span class="mf">1.01</span><span class="p">,</span> <span class="n">delta_tol</span><span class="o">=</span><span class="mf">1.05</span><span class="p">,</span>
                                                  <span class="n">update_adhesion_lengths</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Applies a homogenous isotropic stretch/compression to the cell such that the shortest</span>
<span class="sd">        adhesion is delta</span>

<span class="sd">        :param stretch_factor:  (Default value = 1.01)  How much to scale the cortex ``x -&gt; x * stretch_factor``</span>
<span class="sd">        :type stretch_factor:  float</span>
<span class="sd">        :param delta_tol:  (Default value = 1.05)  Tolerance range for ``delta``.</span>
<span class="sd">        :type delta_tol:  float</span>
<span class="sd">        :param update_adhesion_lengths:  (Default value = True) Whether to perfrom an initial adhesion update.</span>
<span class="sd">        :type update_adhesion_lengths:  bool</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get the current shortest adhesion</span>
        <span class="n">min_adh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_length_of_shortest_adhesion</span><span class="p">(</span><span class="n">rerun_distance_calculation</span><span class="o">=</span><span class="n">update_adhesion_lengths</span><span class="p">)</span>
        <span class="c1"># If it&#39;s longer, stretch the cell until it fits</span>
        <span class="k">while</span> <span class="n">min_adh</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">delta_tol</span><span class="p">:</span>
            <span class="c1"># centroids</span>
            <span class="n">C_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
            <span class="n">C_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
            <span class="c1"># temp locations</span>
            <span class="n">xs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">C_x</span>
            <span class="n">ys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">C_y</span>
            <span class="c1"># scale</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">xs</span> <span class="o">*</span> <span class="n">stretch_factor</span> <span class="o">+</span> <span class="n">C_x</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">ys</span> <span class="o">*</span> <span class="n">stretch_factor</span> <span class="o">+</span> <span class="n">C_y</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_reference_configuration_to_current</span><span class="p">()</span>
            <span class="c1"># now see how small it is</span>
            <span class="n">min_adh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_length_of_shortest_adhesion</span><span class="p">(</span><span class="n">rerun_distance_calculation</span><span class="o">=</span><span class="n">update_adhesion_lengths</span><span class="p">)</span>

        <span class="c1"># Otherwise, if the cell is too big, compress it.</span>
        <span class="k">while</span> <span class="n">min_adh</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="n">delta_tol</span><span class="p">):</span>
            <span class="c1"># centroids</span>
            <span class="n">C_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
            <span class="n">C_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
            <span class="c1"># temp locations</span>
            <span class="n">xs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">C_x</span>
            <span class="n">ys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">C_y</span>
            <span class="c1"># scale</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">xs</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="n">stretch_factor</span><span class="p">)</span> <span class="o">+</span> <span class="n">C_x</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">ys</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="n">stretch_factor</span><span class="p">)</span> <span class="o">+</span> <span class="n">C_y</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_reference_configuration_to_current</span><span class="p">()</span>

            <span class="n">min_adh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_length_of_shortest_adhesion</span><span class="p">(</span><span class="n">rerun_distance_calculation</span><span class="o">=</span><span class="n">update_adhesion_lengths</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_reference_configuration_to_current</span><span class="p">()</span></div>


<div class="viewcode-block" id="Cell.activate_fast_adhesions"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.activate_fast_adhesions">[docs]</a>    <span class="k">def</span> <span class="nf">activate_fast_adhesions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">on_off</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;(De)activates the forces coming from fast adhesions</span>

<span class="sd">        :param on_off:  Set whether fast adhesions exert forces on the cortex.</span>
<span class="sd">        :type on_off: bool</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fast_adhesions_active</span> <span class="o">=</span> <span class="n">on_off</span></div>


<div class="viewcode-block" id="Cell.build_adhesion_tree"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.build_adhesion_tree">[docs]</a>    <span class="k">def</span> <span class="nf">build_adhesion_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">build_polygon</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Builds a kdtree of the possible adhesion locations from self.adhesion_point_coords</span>

<span class="sd">        :param build_polygon:  (Default value = False) Set whether the adhesion polygon will be built. (It&#39;s not used much anymore)</span>
<span class="sd">        :type build_polygon:  bool</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#  Extract the adhesion points</span>
        <span class="n">adhesionNodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_point_coords</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;adhesion_type&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_type</span> <span class="o">=</span> <span class="s2">&quot;nearest&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_type</span> <span class="o">=</span> <span class="s2">&quot;fixed_radius&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_type</span> <span class="o">==</span> <span class="s2">&quot;fixed_length&quot;</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_type</span>  <span class="c1"># Todo remove</span>
        <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adhesion_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span> <span class="s2">&quot;meanfield&quot;</span><span class="p">,</span> <span class="s2">&quot;fixed_radius&quot;</span><span class="p">]),</span> \
            <span class="s2">&quot;Error, self.adhesion_type not available&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_type</span> <span class="o">==</span> <span class="s2">&quot;nearest&quot;</span><span class="p">:</span>
            <span class="c1"># Create the tree with just 1 neighbour</span>
            <span class="n">nbrs</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                    <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">adhesionNodes</span><span class="p">)</span>
        <span class="c1"># Meanfiled adjusts the maximum adhesion length to make sure we can bind everywhere.</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_type</span> <span class="o">==</span> <span class="s2">&quot;meanfield&quot;</span><span class="p">:</span>
            <span class="c1"># Find what the furthest neighbour is</span>
            <span class="n">temp_tree</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                         <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">adhesionNodes</span><span class="p">)</span>
            <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">temp_tree</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">max_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_adhesion_length</span> <span class="o">=</span> <span class="n">max_dist</span> <span class="o">*</span> <span class="mf">1.2</span>
            <span class="c1"># max_dist = self.max_adhesion_length</span>
            <span class="c1"># Now build the new tree for mean-field</span>
            <span class="n">nbrs</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">radius</span><span class="o">=</span><span class="n">max_dist</span> <span class="o">*</span> <span class="mf">1.2</span><span class="p">,</span>
                                    <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">adhesionNodes</span><span class="p">)</span>
        <span class="c1"># Fixed radius gets all connections within self.adhesion_search_radius</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_type</span> <span class="o">==</span> <span class="s2">&quot;fixed_radius&quot;</span><span class="p">:</span>

            <span class="c1"># Create the tree</span>
            <span class="n">nbrs</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">adhesion_search_radius</span><span class="p">,</span>
                                    <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">adhesionNodes</span><span class="p">)</span>
        <span class="c1"># Store it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_tree</span> <span class="o">=</span> <span class="n">nbrs</span>

        <span class="c1"># Create an adhesion polygon as well.</span>
        <span class="k">if</span> <span class="n">build_polygon</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_polygon</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">adhesionNodes</span><span class="p">)</span>

        <span class="k">return</span></div>


<div class="viewcode-block" id="Cell.get_adhesion_nodes_connected_to_xy"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.get_adhesion_nodes_connected_to_xy">[docs]</a>    <span class="k">def</span> <span class="nf">get_adhesion_nodes_connected_to_xy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">sort_by_distance</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the adhesions that will be connected to given a list of (x,y) coordinates.</span>

<span class="sd">        :param nodes:  The list of coordinates that will look for adhesion connections.</span>
<span class="sd">        :type nodes: list</span>
<span class="sd">        :param sort_by_distance:  (Default value = True)  Sort the return list by distance.</span>
<span class="sd">        :type sort_by_distance:  bool</span>
<span class="sd">        :return: The ``distances`` that the nodes have to the adhesion boundary, and the ``indices`` matching the output distances to the input nodes.</span>
<span class="sd">        :rtype: (list, list)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_type</span> <span class="o">==</span> <span class="s2">&quot;nearest&quot;</span><span class="p">:</span>
            <span class="c1"># Query the tree to get the nearest neighbours.</span>
            <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_tree</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Query the tree to get the nearest neighbours.</span>
            <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_tree</span><span class="o">.</span><span class="n">radius_neighbors</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">return_distance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                     <span class="n">sort_results</span><span class="o">=</span><span class="n">sort_by_distance</span><span class="p">)</span>
            <span class="c1"># distances, indices = self.adhesion_tree.kneighbors(nodes)</span>

        <span class="k">return</span> <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span></div>


<div class="viewcode-block" id="Cell.update_adhesion_distances_identifiers_and_indices"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.update_adhesion_distances_identifiers_and_indices">[docs]</a>    <span class="k">def</span> <span class="nf">update_adhesion_distances_identifiers_and_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sort_by_distance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                      <span class="n">build_tree</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Query the adhesion tree to build adhesion connections, storing the distance, id and index of the connection.</span>
<span class="sd">        The data is stored internally, with no output here.</span>

<span class="sd">        :param x:  (Default value = None)  x-coordintes to use.  Defaults to stored cortex x variable.</span>
<span class="sd">        :type x:  np.array</span>
<span class="sd">        :param y:  (Default value = None) y-coordintes to use.  Defaults to stored cortex x variable.</span>
<span class="sd">        :type y:  np.array</span>
<span class="sd">        :param sort_by_distance:  (Default value = True)  Whether to rganise the adhesion connections by distance.</span>
<span class="sd">        :type sort_by_distance:  bool</span>
<span class="sd">        :param build_tree:  (Default value = False)  Whether to fresh-build the adhesion tree.</span>
<span class="sd">        :type build_tree:  bool</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span>

        <span class="n">cortex_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Get the connections and their indices.</span>
        <span class="k">if</span> <span class="n">build_tree</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;adhesion_tree&#39;</span><span class="p">))</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_tree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">build_adhesion_tree</span><span class="p">()</span>
        <span class="n">adh_distances</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_adhesion_nodes_connected_to_xy</span><span class="p">(</span><span class="n">cortex_nodes</span><span class="p">,</span>
                                                                               <span class="n">sort_by_distance</span><span class="o">=</span><span class="n">sort_by_distance</span><span class="p">)</span>

        <span class="c1"># If in hex, just fit closest</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_type</span> <span class="o">==</span> <span class="s2">&quot;nearest&quot;</span><span class="p">:</span>
            <span class="n">adh_distances</span> <span class="o">=</span> <span class="p">[[</span><span class="n">ads</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">if</span> <span class="n">ads</span> <span class="k">else</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">ads</span> <span class="ow">in</span> <span class="n">adh_distances</span><span class="p">]</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">if</span> <span class="n">idx</span> <span class="k">else</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>

        <span class="c1"># get unique attachments for calculating prestrain</span>
        <span class="n">all_attachments</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">adhesion_point_identifiers</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">]</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
        <span class="c1"># self.adhesion_connections_identities_unique = [set(sub_list) for sub_list in all_attachments]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections_identities_unique</span> <span class="o">=</span> <span class="p">[</span><span class="n">Counter</span><span class="p">(</span><span class="n">sub_list</span><span class="p">)</span> <span class="k">for</span> <span class="n">sub_list</span> <span class="ow">in</span> <span class="n">all_attachments</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_type</span> <span class="o">==</span> <span class="s1">&#39;nearest&#39;</span><span class="p">:</span>
            <span class="c1"># Filter anything beyond max adhesion length.</span>
            <span class="n">to_keep</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_adhesion_length</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">adh_distances</span><span class="p">]</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">to_keep</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">))]</span>
            <span class="n">adh_distances</span> <span class="o">=</span> <span class="p">[</span><span class="n">adh_distances</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">to_keep</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">adh_distances</span><span class="p">))]</span>

        <span class="c1"># # Sort by distance</span>
        <span class="c1"># if sort_by_distance:</span>
        <span class="c1">#     sorted_lists = [sort_together([adh_distances[i], indices[i]]) if len(adh_distances[i]) &gt; 0 else [[], []]</span>
        <span class="c1">#                     for i in range(0, adh_distances.shape[0])]</span>
        <span class="c1">#     adh_distances, indices = zip(*sorted_lists)</span>

        <span class="c1"># Limit max number of adhesions for speed</span>
        <span class="n">max_adhesions_stored</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_num_adhesions_for_force</span>
        <span class="c1"># slice_facs = [int(len(d)/max_adhesions_stored) + 1 if int(len(d)/max_adhesions_stored) % 2 ==0</span>
        <span class="c1">#               else int(len(d)/max_adhesions_stored) for d in adh_distances]</span>
        <span class="c1"># adh_distances = [adh_distances[i][::slice_facs[i]] for i in range(len(adh_distances))]</span>
        <span class="c1"># indices = [indices[i][::slice_facs[i]] for i in range(len(adh_distances))]</span>

        <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">adh_distances</span><span class="p">[</span><span class="n">i</span><span class="p">])][:</span><span class="n">max_adhesions_stored</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">adh_distances</span><span class="p">))]</span>
        <span class="n">adh_distances</span> <span class="o">=</span> <span class="p">[</span><span class="n">adh_distances</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">adh_distances</span><span class="p">[</span><span class="n">i</span><span class="p">])][:</span><span class="n">max_adhesions_stored</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span>
                         <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">adh_distances</span><span class="p">))]</span>

        <span class="c1"># Store the distances</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_distances</span> <span class="o">=</span> <span class="n">adh_distances</span>
        <span class="c1"># Store the connections</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">adhesion_point_coords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">]</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
        <span class="c1"># And their identities</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections_identities</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">adhesion_point_identifiers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">]</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
        <span class="c1"># and their spacings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections_spacings</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">adhesion_point_spacings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">]</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span></div>


<div class="viewcode-block" id="Cell.get_total_adhesion_force_from_adhesion_indices"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.get_total_adhesion_force_from_adhesion_indices">[docs]</a>    <span class="k">def</span> <span class="nf">get_total_adhesion_force_from_adhesion_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord</span><span class="p">,</span> <span class="n">adhesion_index</span><span class="p">,</span> <span class="n">is_intersection</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;For fast adhesions.  Given (x,y) coord on this cortex and index (adhesion_idx) in adhesion list that it is connected to,</span>
<span class="sd">        calculate vector force.  Note self.adhesion_connections[adhesion_index] can be a list of multiple connections.</span>

<span class="sd">        :param coord:  The (x,y) coord to get the adhesion force for.</span>
<span class="sd">        :type adhesion_index:   The index of the adhesion node it will be connected to.</span>
<span class="sd">        :param is_intersection:  (Default value = False).  Unused now.  If it is intersecting the adhesion boundary, the force is reversed.</span>
<span class="sd">        :type is_intersection:  bool</span>
<span class="sd">        :return: The ``distances`` that the nodes have to the adhesion boundary, and the ``indices`` matching the output distances to the input nodes.</span>
<span class="sd">        :rtype: (list, list)</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get the lengths of the connections that were made.</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_distances</span><span class="p">[</span><span class="n">adhesion_index</span><span class="p">]</span>

        <span class="c1"># This if statement is depreciated \todo</span>
        <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_adhesion_length</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span>
            <span class="n">force</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega0</span> <span class="o">*</span> <span class="n">e</span>

        <span class="c1"># Get force magnitude</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Make into numpy array</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

            <span class="c1"># calculate the forces</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_force_law</span> <span class="o">==</span> <span class="s2">&quot;spring&quot;</span><span class="p">:</span>
                <span class="c1"># Get spring extension</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span>
                <span class="c1"># Set maximum bonding distance</span>
                <span class="n">e</span><span class="p">[</span><span class="n">d</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_adhesion_length</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
                <span class="c1"># Calc spring force</span>
                <span class="n">force</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega0</span> <span class="o">*</span> <span class="n">e</span>

                <span class="c1"># Multiply by spacing on the other cortices.</span>
                <span class="n">force</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections_spacings</span><span class="p">[</span><span class="n">adhesion_index</span><span class="p">])</span>
                <span class="c1"># spacing = np.array(self.adhesion_connections_spacings[adhesion_index])</span>
                <span class="c1"># np.multiply(force, spacing[:, np.newaxis], casting=&#39;unsafe&#39;, out=force)</span>

                <span class="c1"># Short range repulsion if compressed</span>
                <span class="c1"># force[e &lt; 0] = self.get_dOmega_dY( d[e&lt;0] )</span>
                <span class="c1"># force[e &lt; 0] *= 1/d[e &lt; 0]</span>
                <span class="c1"># force[e &lt; 0] *= 0.5*(np.log(d[e &lt; 0]) / np.log(0.5))</span>
                <span class="c1"># force[e &lt; 0] = - 1 * self.omega0 * (np.log(d[e &lt; 0]) / np.log(0.5))</span>

                <span class="c1"># scale the force from each adhesion using softmax function</span>
                <span class="n">exp_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_beta_scale_factor</span>
                <span class="n">dist_scaling</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">exp_factor</span> <span class="o">*</span> <span class="n">d</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist_scaling</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">dist_scaling</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist_scaling</span><span class="p">)</span>
                <span class="n">force</span> <span class="o">*=</span> <span class="n">dist_scaling</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Fast adhesions must have self.adhesion_force_law=&quot;spring&quot;&#39;</span><span class="p">)</span>

            <span class="c1"># # Log_1/2 force</span>
            <span class="c1"># stretch = d / (self.delta * multiplier)</span>
            <span class="c1"># # force[stretch &lt; 1] = self.omega0 * (np.log(stretch[stretch &lt; 1]) / np.log(0.5))</span>
            <span class="c1"># force = self.omega0 * (np.log(stretch) / np.log(0.5))</span>
            <span class="c1"># force[stretch &lt;= 1e-8] = self.omega0 * (np.log(1e-8) / np.log(0.5))</span>

        <span class="c1"># If the adhesion density != 1 on this cortex, or the connection, scale the forces</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">ad_den</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">ad_den</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_density_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()]):</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">[</span><span class="n">adhesion_index</span><span class="p">]</span>
            <span class="n">force_scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_density_dict</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">ids</span><span class="p">)))</span>
            <span class="c1"># force_scale = np.array(list(map(lambda x: self.adhesion_density_dict[x] * id_spacing_dict[x], ids)))</span>
            <span class="n">force</span> <span class="o">*=</span> <span class="n">force_scale</span>

        <span class="c1"># Get the unit direction of the force</span>
        <span class="n">dirs</span> <span class="o">=</span> <span class="p">[[</span><span class="n">ad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ad</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">ad</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections</span><span class="p">[</span><span class="n">adhesion_index</span><span class="p">]]</span>
        <span class="n">dirs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dirs</span><span class="p">)</span>
        <span class="n">dirs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">dirs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">inner1d</span><span class="p">(</span><span class="n">dirs</span><span class="p">,</span> <span class="n">dirs</span><span class="p">))[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>

        <span class="c1"># If we haven&#39;t intersected the other cell, multiply by the direction</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_intersection</span><span class="p">:</span>
            <span class="c1"># Mulitply normals by magnitude of force to get force vectors</span>
            <span class="n">vector_of_forces</span> <span class="o">=</span> <span class="n">dirs</span> <span class="o">*</span> <span class="n">force</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vector_of_forces</span> <span class="o">=</span> <span class="o">-</span> <span class="n">dirs</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">force</span><span class="p">)</span>  <span class="c1"># 1e6</span>

        <span class="c1"># Sum them all to get the average.</span>
        <span class="n">vector_force</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vector_of_forces</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">vector_force</span></div>

<div class="viewcode-block" id="Cell.get_fast_adhesion_forces_across_cortex"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.get_fast_adhesion_forces_across_cortex">[docs]</a>    <span class="k">def</span> <span class="nf">get_fast_adhesion_forces_across_cortex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sort_by_distance</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Query the adhesion tree to get indices of neighouring cortices within the max adhesion length.</span>
<span class="sd">        Then calculate the distance to each point and calculate the force.</span>

<span class="sd">        :param x:  (Default value = None)  x-coordintes to use.  Defaults to stored cortex x variable.</span>
<span class="sd">        :type x:  np.array</span>
<span class="sd">        :param y:  (Default value = None) y-coordintes to use.  Defaults to stored cortex y variable.</span>
<span class="sd">        :type y:  np.array</span>
<span class="sd">        :param sort_by_distance:  (Default value = True) Organise the adhesions by distance.</span>
<span class="sd">        :type sort_by_distance:  bool</span>
<span class="sd">        :return: A list of the adhesion forces acting across the cortex.</span>
<span class="sd">        :rtype: np.array</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span>

        <span class="c1"># Get total num nodes</span>
        <span class="n">num_nodes</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span>

        <span class="c1"># Get (x,y) coords of nodes on this cortex</span>
        <span class="n">cortex_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Update the distances</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_adhesion_distances_identifiers_and_indices</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sort_by_distance</span><span class="o">=</span><span class="n">sort_by_distance</span><span class="p">)</span>

        <span class="c1"># Determine if we have intersected another cell or the adhesion boundary.  Actually this isn&#39;t necessary</span>
        <span class="c1"># idxs = self.get_intersection_indices(cortex_nodes)</span>
        <span class="c1"># intersection_bools = np.zeros(num_nodes)</span>
        <span class="c1"># intersection_bools[idxs] = True</span>
        <span class="c1"># intersection_bools = np.zeros(num_nodes)</span>

        <span class="c1"># Calculate the forces</span>
        <span class="n">forces</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_total_adhesion_force_from_adhesion_indices</span><span class="p">(</span><span class="n">cortex_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_nodes</span><span class="p">)]</span>
        <span class="n">forces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">forces</span><span class="p">)</span>

        <span class="c1"># Scale the forces with the discretisation.</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">spacing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_xy_segment_lengths</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>  <span class="c1"># ** 2</span>
            <span class="c1"># Multiple forces by scaling</span>
            <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">forces</span><span class="p">,</span> <span class="n">spacing</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;unsafe&#39;</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">forces</span><span class="p">)</span>

        <span class="c1"># Storing the forces so they don&#39;t need to be recalculated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_forces</span> <span class="o">=</span> <span class="n">forces</span>

        <span class="k">return</span> <span class="n">forces</span></div>

<div class="viewcode-block" id="Cell.get_sdk_forces_across_cortex"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.get_sdk_forces_across_cortex">[docs]</a>    <span class="k">def</span> <span class="nf">get_sdk_forces_across_cortex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a vector len(self.s) of the total force on each cortex node due to sdk</span>

<span class="sd">        :param x:  (Default value = None)  x-coordintes to use.  Defaults to stored cortex x variable.</span>
<span class="sd">        :type x:  np.array</span>
<span class="sd">        :param y:  (Default value = None) y-coordintes to use.  Defaults to stored cortex y variable.</span>
<span class="sd">        :type y:  np.array</span>
<span class="sd">        :param s:  (Default value = None) S_0-coordintes to use.  Defaults to stored cortex S_0 variable.</span>
<span class="sd">        :type s:  np.array</span>
<span class="sd">        :return: A list of the sidekick adhesion forces acting across the cortex.</span>
<span class="sd">        :rtype: np.array</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">s</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">x</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">y</span>

        <span class="c1"># Update the mesh spacing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_deformed_mesh_spacing</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="c1"># Intitialise the vector of forces, which we will fill for every node that has a sidekick adhesion.</span>
        <span class="n">force_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">s</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="c1"># For every sidekick adhesion, find the node it&#39;s attached to and calculate the force.</span>
        <span class="k">for</span> <span class="n">ad</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sidekick_adhesions</span><span class="p">:</span>
            <span class="n">local_idx</span> <span class="o">=</span> <span class="n">ad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Using the collocation method, the size of x changes. If it&#39;s too big, just use end value</span>
            <span class="n">local_idx</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">local_idx</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">local_idx</span>
            <span class="n">x_local</span><span class="p">,</span> <span class="n">y_local</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">local_idx</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">local_idx</span><span class="p">]</span>
            <span class="c1"># Force and direction</span>
            <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">ad</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_local</span><span class="p">,</span> <span class="n">ad</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_local</span>
            <span class="n">direction</span> <span class="o">=</span> <span class="p">[</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">]</span>
            <span class="n">magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">direction</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">direction</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">direction</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="n">magnitude</span>
            <span class="n">direction</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/=</span> <span class="n">magnitude</span>

            <span class="n">length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dx</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">+</span> <span class="n">dy</span> <span class="o">*</span> <span class="n">dy</span><span class="p">)</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sdk_restlen</span> <span class="k">if</span> <span class="n">length</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_adhesion_length</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="n">force</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sdk_stiffness</span> <span class="o">*</span> <span class="n">e</span>

            <span class="n">force_acting</span> <span class="o">=</span> <span class="p">[</span><span class="n">direction</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">force</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">deformed_mesh_spacing</span><span class="p">[</span><span class="n">local_idx</span><span class="p">],</span>
                            <span class="n">direction</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">force</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">deformed_mesh_spacing</span><span class="p">[</span><span class="n">local_idx</span><span class="p">]]</span>

            <span class="n">force_vector</span><span class="p">[</span><span class="n">local_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">force_acting</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># * self.mesh_spacing[local_idx]</span>
            <span class="n">force_vector</span><span class="p">[</span><span class="n">local_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">force_acting</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># * self.mesh_spacing[local_idx]</span>

        <span class="k">return</span> <span class="n">force_vector</span></div>

<div class="viewcode-block" id="Cell.get_slow_adhesion_forces_across_cortex"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.get_slow_adhesion_forces_across_cortex">[docs]</a>    <span class="k">def</span> <span class="nf">get_slow_adhesion_forces_across_cortex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate a vector len(self.s) giving the total force at every cortexz node coming from the population of</span>
<span class="sd">        slow adhesions.</span>

<span class="sd">        :param x:  (Default value = None)  x-coordintes to use.  Defaults to stored cortex x variable.</span>
<span class="sd">        :type x:  np.array</span>
<span class="sd">        :param y:  (Default value = None) y-coordintes to use.  Defaults to stored cortex y variable.</span>
<span class="sd">        :type y:  np.array</span>
<span class="sd">        :return: A list of the slow adhesion forces acting across the cortex.</span>
<span class="sd">        :rtype: np.array</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">x</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">y</span>

        <span class="c1">#Update mesh spacing for scaling</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_deformed_mesh_spacing</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="n">force_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">ad</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slow_adhesions</span><span class="p">:</span>
            <span class="c1"># Slow adhesion data format = (local_cell_index, other_cell_x, other_cell_y, other_cell_spacing)</span>

            <span class="n">local_idx</span> <span class="o">=</span> <span class="n">ad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Using the collocation method, the size of x changes. If it&#39;s too big, just use end value</span>
            <span class="n">local_idx</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">local_idx</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">local_idx</span>
            <span class="n">x_local</span><span class="p">,</span> <span class="n">y_local</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">local_idx</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">local_idx</span><span class="p">]</span>
            <span class="c1"># Force and direction</span>
            <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">ad</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_local</span><span class="p">,</span> <span class="n">ad</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_local</span>
            <span class="n">direction</span> <span class="o">=</span> <span class="p">[</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">]</span>
            <span class="n">magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">direction</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">direction</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">direction</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="n">magnitude</span>
            <span class="n">direction</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/=</span> <span class="n">magnitude</span>

            <span class="n">length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dx</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">+</span> <span class="n">dy</span> <span class="o">*</span> <span class="n">dy</span><span class="p">)</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="k">if</span> <span class="n">length</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_adhesion_length</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="n">force</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega0</span> <span class="o">*</span> <span class="n">e</span>

            <span class="n">force_acting</span> <span class="o">=</span> <span class="p">[</span><span class="n">direction</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">force</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">deformed_mesh_spacing</span><span class="p">[</span><span class="n">local_idx</span><span class="p">],</span>
                            <span class="n">direction</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">force</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">deformed_mesh_spacing</span><span class="p">[</span><span class="n">local_idx</span><span class="p">]]</span>

            <span class="c1"># Multiple by mesh spacing on the other cotrex.</span>
            <span class="n">other_mesh_spacing</span> <span class="o">=</span> <span class="n">ad</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="n">force_vector</span><span class="p">[</span><span class="n">local_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">force_acting</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">other_mesh_spacing</span>
            <span class="n">force_vector</span><span class="p">[</span><span class="n">local_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">force_acting</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">other_mesh_spacing</span>

        <span class="k">return</span> <span class="n">force_vector</span></div>


<div class="viewcode-block" id="Cell.get_total_adhesion_force_across_cortex"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.get_total_adhesion_force_across_cortex">[docs]</a>    <span class="k">def</span> <span class="nf">get_total_adhesion_force_across_cortex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the total adhesion force, with fast, sdk and slow adhesions</span>

<span class="sd">        :param x:  (Default value = None)  x-coordintes to use.  Defaults to stored cortex x variable.</span>
<span class="sd">        :type x:  np.array</span>
<span class="sd">        :param y:  (Default value = None) y-coordintes to use.  Defaults to stored cortex y variable.</span>
<span class="sd">        :type y:  np.array</span>
<span class="sd">        :param s:  (Default value = None) S_0-coordintes to use.  Defaults to stored cortex S_0 variable.</span>
<span class="sd">        :type s:  np.array</span>
<span class="sd">        :return: A list of the sidekick adhesion forces acting across the cortex.</span>
<span class="sd">        :rtype: np.array</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">x</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">y</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">s</span>

        <span class="c1"># Get fast adhesion forces</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fast_adhesions_active</span><span class="p">:</span>
            <span class="n">ad_forces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fast_adhesion_forces_across_cortex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ad_forces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="c1"># Sidekick forces</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sidekick_adhesions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sdk_forces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sdk_forces_across_cortex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
            <span class="c1"># add the forces to the adhesions</span>
            <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ad_forces</span><span class="p">,</span> <span class="n">sdk_forces</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;unsafe&#39;</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">ad_forces</span><span class="p">)</span>

        <span class="c1"># Slow adhesions</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slow_adhesions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">slow_adh_forces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_slow_adhesion_forces_across_cortex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="c1"># add the forces to the adhesions</span>
            <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ad_forces</span><span class="p">,</span> <span class="n">slow_adh_forces</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;unsafe&#39;</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">ad_forces</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_forces</span> <span class="o">=</span> <span class="n">ad_forces</span>

        <span class="k">return</span> <span class="n">ad_forces</span></div>

<div class="viewcode-block" id="Cell.get_protrusion_force"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.get_protrusion_force">[docs]</a>    <span class="k">def</span> <span class="nf">get_protrusion_force</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make a protrusion pointing to another cell and get a list of the forces acting across the cortex due to it</span>
<span class="sd">         (this will mostly be a sparse list of [0,0] except where the protrusion is)  \todo this is old might not work anymore</span>

<span class="sd">        :param x:  (Default value = None)  x-coordintes to use.  Defaults to stored cortex x variable.</span>
<span class="sd">        :type x:  np.array</span>
<span class="sd">        :param y:  (Default value = None) y-coordintes to use.  Defaults to stored cortex y variable.</span>
<span class="sd">        :type y:  np.array</span>
<span class="sd">        :return: A list of the forces acting across the cortex due to protrusions.</span>
<span class="sd">        :rtype: np.array</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">protrusion_target</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">protrusion_force</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">target_cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">protrusion_target</span>

        <span class="c1"># Stack a list of the x/y positions</span>
        <span class="n">nodes_on_cortex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Get the coordinates of the target cell from the list of possible adhesion points.</span>
        <span class="n">adhesionNodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_point_coords</span>
        <span class="c1"># Extract which cortex they are adhering to</span>
        <span class="n">id_list_adh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_point_identifiers</span>
        <span class="c1"># Get the ones belonging to he desired cortex only.</span>
        <span class="n">target_cell_nodes</span> <span class="o">=</span> <span class="n">adhesionNodes</span><span class="p">[</span><span class="n">id_list_adh</span> <span class="o">==</span> <span class="n">target_cell</span><span class="p">]</span>

        <span class="c1"># Create a KD tree to get the distances between all nodes</span>
        <span class="n">tree_of_neighbours</span> <span class="o">=</span> <span class="n">cKDTree</span><span class="p">(</span><span class="n">target_cell_nodes</span><span class="p">)</span>
        <span class="n">distance</span><span class="p">,</span> <span class="n">indices_to_points</span> <span class="o">=</span> <span class="n">tree_of_neighbours</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">nodes_on_cortex</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Find the closest node on this cortex</span>
        <span class="n">node_on_this_cortex</span> <span class="o">=</span> <span class="n">nodes_on_cortex</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distance</span><span class="p">)]</span>
        <span class="c1"># And the closest on the neighbour</span>
        <span class="n">node_on_target_cortex</span> <span class="o">=</span> <span class="n">target_cell_nodes</span><span class="p">[</span><span class="n">indices_to_points</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distance</span><span class="p">)]]</span>

        <span class="c1"># Specify the direction of the force</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="n">node_on_target_cortex</span> <span class="o">-</span> <span class="n">node_on_this_cortex</span>
        <span class="n">direction_unit</span> <span class="o">=</span> <span class="n">direction</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">inner1d</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">direction</span><span class="p">))</span>
        <span class="c1"># Add the force</span>
        <span class="n">force</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">protrusion_force</span> <span class="o">*</span> <span class="n">direction_unit</span>

        <span class="n">force_list</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_adhesion_length</span> <span class="o">*</span> <span class="o">.</span><span class="mi">75</span><span class="p">:</span>
            <span class="n">force_list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distance</span><span class="p">)]</span> <span class="o">=</span> <span class="n">force</span>

        <span class="n">force_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">force_list</span><span class="p">)</span>

        <span class="c1"># Get the ids of the nearest/most common cortex</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="n">Counter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>
               <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">else</span> <span class="s1">&#39;none&#39;</span>
               <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
        <span class="c1"># Remove forces on the boundary</span>
        <span class="n">force_list</span><span class="p">[</span><span class="n">ids</span> <span class="o">==</span> <span class="s1">&#39;boundary&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="k">return</span> <span class="n">force_list</span></div>


<div class="viewcode-block" id="Cell.update_prestrains"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.update_prestrains">[docs]</a>    <span class="k">def</span> <span class="nf">update_prestrains</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update the values of prestretches (called prestrain here based on the identity of (fast) adhesion connections    </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">prestrains</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_prestrains</span><span class="p">()</span></div>


<div class="viewcode-block" id="Cell.get_prestrains"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.get_prestrains">[docs]</a>    <span class="k">def</span> <span class="nf">get_prestrains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an array of the calculated prestrethc (called prestrain) at every mesh point, using the</span>
<span class="sd">        fast adhesion methods</span>

<span class="sd">        :param shape:  (Default value = None) The desired return shape (used when solving bvp with collocation nodes).</span>
<span class="sd">        :type shape:  int</span>
<span class="sd">        :return: The prestretch across the cortex.</span>
<span class="sd">        :rtype: np.array</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Error, need to update adhesions&#39;</span>

        <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">shape</span>

        <span class="n">prestrain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="c1"># Calculate prestrain based on type</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()]):</span>

            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">prestrain_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;most_common&quot;</span><span class="p">,</span> <span class="s2">&quot;average&quot;</span><span class="p">,</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span> <span class="s2">&quot;nearest&quot;</span><span class="p">],</span> <span class="s2">&quot;Error self.prestrain_type &quot;</span> \
                                                                                        <span class="s2">&quot;not in [most_common, average, min, nearest].&quot;</span>

            <span class="c1"># Choose to prestain in cortex according to most common connection:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prestrain_type</span> <span class="o">==</span> <span class="s2">&quot;most_common&quot;</span><span class="p">:</span>
                <span class="n">id_list</span> <span class="o">=</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">ad_id</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">Counter</span><span class="p">(</span><span class="n">ad_id</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">)</span> <span class="k">if</span> <span class="n">ad_id</span> <span class="k">else</span> <span class="s1">&#39;none&#39;</span>
                           <span class="k">for</span> <span class="n">ad_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">]</span>
                <span class="c1"># Get the dictionary to scale with</span>
                <span class="n">prestrain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">val</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="p">[</span><span class="n">val</span><span class="p">],</span> <span class="n">id_list</span><span class="p">)))</span>

            <span class="c1"># choose the average prestrain</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">prestrain_type</span> <span class="o">==</span> <span class="s2">&quot;average&quot;</span><span class="p">:</span>
                <span class="c1"># prestrain = np.array([np.mean([self.prestrain_dict[val] for val in sub_list])</span>
                <span class="c1">#                             if sub_list else 1. for sub_list in self.adhesion_connections_identities])</span>
                <span class="c1"># If it&#39;s a counter dict</span>
                <span class="n">prestrain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">sum</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">sub_list</span><span class="o">.</span><span class="n">items</span><span class="p">())</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">sub_list</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                                      <span class="k">if</span> <span class="n">sub_list</span> <span class="k">else</span> <span class="mf">1.</span> <span class="k">for</span> <span class="n">sub_list</span> <span class="ow">in</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections_identities_unique</span><span class="p">[:</span><span class="n">shape</span><span class="p">]])</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">prestrain_type</span> <span class="o">==</span> <span class="s2">&quot;min&quot;</span><span class="p">:</span>
                <span class="c1"># choose the min prestrain (will contract if any ads are connected to the cortex)</span>
                <span class="c1"># prestrain = np.array([np.min([self.prestrain_dict[val] for val in sub_list])</span>
                <span class="c1">#                       if sub_list else 1. for sub_list in self.adhesion_connections_identities])</span>
                <span class="c1"># # When it&#39;s a set</span>
                <span class="c1"># prestrain = np.array([np.min([self.prestrain_dict[val] for val in sub_list])</span>
                <span class="c1">#                       if sub_list else 1. for sub_list in self.adhesion_connections_identities_unique])</span>
                <span class="c1"># If it&#39;s a counter dict</span>
                <span class="n">prestrain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">min</span><span class="p">(</span><span class="n">sub_list</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                                      <span class="k">if</span> <span class="n">sub_list</span> <span class="k">else</span> <span class="mf">1.</span> <span class="k">for</span> <span class="n">sub_list</span> <span class="ow">in</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections_identities_unique</span><span class="p">[:</span><span class="n">shape</span><span class="p">]])</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">prestrain_type</span> <span class="o">==</span> <span class="s2">&quot;nearest&quot;</span><span class="p">:</span>
                <span class="c1"># prestrain = np.array([self.prestrain_dict[self.adhesion_connections_identities[idx][np.argmin(self.adhesion_distances[idx])]]</span>
                <span class="c1">#                       if self.adhesion_connections_identities[idx] else 1. for idx in range(x.size)])</span>
                <span class="c1">#  If sorted, choose nearest.</span>
                <span class="n">prestrain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">prestrain_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                     <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">else</span> <span class="mf">1.</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">shape</span><span class="p">)])</span>

        <span class="c1"># Add any local prestrian to specific indices</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prestrain_indices_list</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">indices_to_change</span> <span class="o">=</span> <span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">prestrain_indices_list</span><span class="p">]</span>
            <span class="n">values_to_change</span> <span class="o">=</span> <span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">prestrain_indices_list</span><span class="p">]</span>
            <span class="n">prestrain</span><span class="p">[</span><span class="n">indices_to_change</span><span class="p">]</span> <span class="o">*=</span> <span class="n">values_to_change</span>

        <span class="k">return</span> <span class="n">prestrain</span></div>


<div class="viewcode-block" id="Cell.get_first_derivative_of_cortex_variables"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.get_first_derivative_of_cortex_variables">[docs]</a>    <span class="k">def</span> <span class="nf">get_first_derivative_of_cortex_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">D</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the first derivative of all cortex variables. (Note, return order differs to input order \todo)</span>

<span class="sd">        :param x:  (Default value = None)  x-coordinates to use.  Defaults to stored cortex x variable.</span>
<span class="sd">        :type x:  np.array</span>
<span class="sd">        :param y:  (Default value = None) y-coordinates to use.  Defaults to stored cortex y variable.</span>
<span class="sd">        :type y:  np.array</span>
<span class="sd">        :param theta:  (Default value = None) cortex angles to use.  Defaults to stored cortex theta variable.</span>
<span class="sd">        :type theta:  np.array</span>
<span class="sd">        :param gamma:  (Default value = None) cortex stretches to use.  Defaults to stored cortex gamma variable.</span>
<span class="sd">        :type gamma:  np.array</span>
<span class="sd">        :param C:  (Default value = None) theta&#39; to use.  Defaults to stored cortex C variable.</span>
<span class="sd">        :type C:  np.array</span>
<span class="sd">        :param D:  (Default value = None) theta&#39;&#39; to use.  Defaults to stored cortex D variable.</span>
<span class="sd">        :type D:  np.array</span>
<span class="sd">        :param s:  (Default value = None) S_0-coordintes to use.  Defaults to stored cortex S_0 variable.</span>
<span class="sd">        :type s:  np.array</span>
<span class="sd">        :return: A list of arrays, where each array is the first deriv of a cortex variable.</span>
<span class="sd">        :rtype: list</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">update_adh_force</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_forces</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">False</span>

        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">x</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">y</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="k">if</span> <span class="n">theta</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">theta</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="k">if</span> <span class="n">gamma</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">gamma</span>
        <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span> <span class="k">if</span> <span class="n">C</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">C</span>
        <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="k">if</span> <span class="n">D</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">D</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">s</span>

        <span class="c1">#######</span>
        <span class="c1"># External forces</span>
        <span class="c1">#######</span>

        <span class="c1"># Get adhesion forces</span>
        <span class="n">ad_forces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_forces</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">update_adh_force</span> <span class="k">else</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">get_total_adhesion_force_across_cortex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

        <span class="c1"># Include protrusions</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">protrusion_force</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Add the protrusion forces</span>
            <span class="n">protrusion_forces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_protrusion_force</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="c1"># add the protrusion forces to the adhesions</span>
            <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ad_forces</span><span class="p">,</span> <span class="n">protrusion_forces</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;unsafe&#39;</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">ad_forces</span><span class="p">)</span>

        <span class="c1"># Project onto normal and tangential directions</span>
        <span class="n">normal</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)]</span>
        <span class="c1"># normal = [np.sin(theta), -np.cos(theta)]</span>
        <span class="n">tangent</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)]</span>
        <span class="n">gradOmegaDotN</span> <span class="o">=</span> <span class="p">(</span><span class="n">ad_forces</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">normal</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">gradOmegaDotT</span> <span class="o">=</span> <span class="p">(</span><span class="n">ad_forces</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">tangent</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Pressure forces:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pressure_on_off</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">area_stiffness</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">pressure</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c1"># pressure = self.pressure</span>
            <span class="n">pressure</span> <span class="o">=</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">area_stiffness</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_area</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pref_area</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">pressure</span>

            <span class="c1"># Get the ids of the nearest/most common cortex</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="p">[</span>
                <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="n">Counter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">else</span> <span class="s1">&#39;none&#39;</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>

            <span class="c1"># Scale medial with adhesion density</span>
            <span class="n">pressure_scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">val</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_density_dict</span><span class="p">[</span><span class="n">val</span><span class="p">],</span> <span class="n">ids</span><span class="p">)))</span>
            <span class="c1"># Remove pressure force if there are no cadherins</span>
            <span class="n">pressure_scale</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ad_forces</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">spacing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_xy_segment_lengths</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

            <span class="n">total_pressure</span> <span class="o">=</span> <span class="n">pressure</span> <span class="o">*</span> <span class="n">pressure_scale</span> <span class="o">*</span> <span class="n">spacing</span>

            <span class="c1"># Add pressure to normal force</span>
            <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">gradOmegaDotN</span><span class="p">,</span> <span class="n">total_pressure</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;unsafe&#39;</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">gradOmegaDotN</span><span class="p">)</span>

        <span class="c1">#######</span>
        <span class="c1"># Add cortex material forces</span>
        <span class="c1">#######</span>

        <span class="c1"># Get the prestrains.</span>
        <span class="n">prestrain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_prestrains</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

        <span class="c1"># Now gamma (alpha in manuscript) and D</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">constitutive_model</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
            <span class="c1"># Gradients of prestrain</span>
            <span class="n">prestrain_inv</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">prestrain</span>
            <span class="n">prestrain_grad1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">prestrain</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
            <span class="c1"># prestrain_grad1 = savgol_filter(prestrain_grad1, 21, 1)</span>
            <span class="n">prestrain_grad2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">prestrain_grad1</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
            <span class="c1"># prestrain_grad2 = savgol_filter(prestrain_grad2, 21, 1)</span>

            <span class="c1"># Gamma</span>
            <span class="n">gamma_inv</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">gamma</span>
            <span class="c1"># d_gamma_ds = self.kappa * (prestrain_inv ** 3) * gamma_inv * C * (C * prestrain_grad1 - D * gamma) \</span>
            <span class="n">d_gamma_ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span> <span class="o">*</span> <span class="p">(</span><span class="n">prestrain_inv</span> <span class="o">**</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">gamma_inv</span> <span class="o">*</span> <span class="n">C</span> <span class="o">*</span> <span class="p">(</span><span class="n">C</span> <span class="o">*</span> <span class="n">prestrain_grad1</span> <span class="o">-</span> <span class="n">D</span> <span class="o">*</span> <span class="n">prestrain</span><span class="p">)</span> \
                         <span class="o">-</span> <span class="n">prestrain</span> <span class="o">*</span> <span class="n">gradOmegaDotT</span>

            <span class="c1"># D</span>
            <span class="n">dDds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span> <span class="o">*</span> <span class="n">D</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">prestrain_grad1</span> <span class="o">*</span> <span class="n">prestrain_inv</span> <span class="o">+</span> <span class="n">d_gamma_ds</span> <span class="o">*</span> <span class="n">gamma_inv</span><span class="p">)</span> <span class="o">+</span> \
                   <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span> <span class="o">*</span> <span class="n">C</span> <span class="o">*</span> <span class="p">(</span><span class="n">prestrain_grad2</span> <span class="o">*</span> <span class="n">prestrain_inv</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">prestrain_grad1</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">gamma_inv</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span>
                                     <span class="n">d_gamma_ds</span> <span class="o">*</span> <span class="n">prestrain_grad1</span> <span class="o">*</span> <span class="n">gamma_inv</span> <span class="o">*</span> <span class="n">prestrain_inv</span><span class="p">)</span> <span class="o">+</span> \
                   <span class="p">(</span><span class="n">prestrain</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">C</span> <span class="o">*</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> \
                   <span class="p">(</span><span class="n">prestrain</span> <span class="o">**</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">gradOmegaDotN</span>
            <span class="n">dDds</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">constitutive_model</span> <span class="o">==</span> <span class="s1">&#39;hyperelastic&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Hyperelastic model not implemented&#39;</span><span class="p">)</span>

        <span class="c1"># Theta</span>
        <span class="n">dThetaDs</span> <span class="o">=</span> <span class="n">C</span>

        <span class="c1"># C</span>
        <span class="n">dCds</span> <span class="o">=</span> <span class="n">D</span>

        <span class="c1"># X, Y</span>
        <span class="n">dXds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">prestrain</span><span class="p">)</span>
        <span class="n">dYds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">prestrain</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">dThetaDs</span><span class="p">,</span> <span class="n">d_gamma_ds</span><span class="p">,</span> <span class="n">dXds</span><span class="p">,</span> <span class="n">dYds</span><span class="p">,</span> <span class="n">dDds</span><span class="p">,</span> <span class="n">dCds</span><span class="p">))</span></div>


<div class="viewcode-block" id="Cell.funcForScipyBVPSolver"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.funcForScipyBVPSolver">[docs]</a>    <span class="k">def</span> <span class="nf">funcForScipyBVPSolver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">U</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Function to pass to Scipy&#39;s BVP solver; returns the cortex equilibrium equations from the force balance.</span>
<span class="sd">        U = [theta, gamma, x, y, D, C]</span>

<span class="sd">        :param s: S_0 cortex coordintes (the undeformed mesh).</span>
<span class="sd">        :type s:  np.array</span>
<span class="sd">        :param U: A list of the cortex variables ``[theta, gamma, x, y, C, D]`` (passed as arrays; unintuitive ordering)</span>
<span class="sd">        :type U:</span>
<span class="sd">        :return: The first derivative of the cortex variables, which will be solved by Scipy.</span>
<span class="sd">        :rtype: list</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">theta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">U</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">U</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">U</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">U</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">U</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">U</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>

        <span class="n">cortex_eqns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_first_derivative_of_cortex_variables</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="o">=</span><span class="n">D</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cortex_eqns</span></div>


<div class="viewcode-block" id="Cell.bvp_bcs"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.bvp_bcs">[docs]</a>    <span class="k">def</span> <span class="nf">bvp_bcs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ya</span><span class="p">,</span> <span class="n">yb</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check how close we are to periodic BCS for cortex variables.  Used for solving BVP</span>

<span class="sd">        :param ya: The current value of the cortex variables at the first index: ``[theta[0], gamma[0], x[0], y[0], C[0], D[0]]``</span>
<span class="sd">        :type ya: list</span>
<span class="sd">        :param yb: The current value of the cortex variables at the first index: ``[theta[-1], gamma[-1], x[-1], y[-1], C[-1], D[-1]]``</span>
<span class="sd">        :type yb: list</span>
<span class="sd">        :return: A list of the differences between the enp-point variables (theta is mod 2pi).</span>
<span class="sd">        :rtype: np.array</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">BCStateVector</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># For theta  it needs to be mod(2pi)</span>
        <span class="n">BCStateVector</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ya</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">-</span> <span class="n">yb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
        <span class="c1"># Others are just continuity.</span>
        <span class="n">BCStateVector</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ya</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">yb</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">BCStateVector</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ya</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">yb</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">BCStateVector</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ya</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">yb</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">BCStateVector</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ya</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="n">yb</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">/</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">BCStateVector</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ya</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">-</span> <span class="n">yb</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">/</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">BCStateVector</span><span class="p">)</span></div>


<div class="viewcode-block" id="Cell.solve_bvp"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.solve_bvp">[docs]</a>    <span class="k">def</span> <span class="nf">solve_bvp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Solve BVP for cortex variables using Scipy&#39;s BVP solver</span>

<span class="sd">        :return:  A tuple, whether solving was a success; a list, the new cortex variables: ``[s, theta, gamma, x, y, C, D]``</span>
<span class="sd">        :rtype: (bool, list)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">verbose</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;Solving BVP for cell </span><span class="si">%s</span><span class="s2"> &quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="p">]),</span> <span class="nb">object</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Make copies of the variables and reduce their length if the lists are too long.</span>
        <span class="n">gammaTemp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">+</span> <span class="mf">0.</span>
        <span class="n">thetaTemp</span><span class="p">,</span> <span class="n">xTemp</span><span class="p">,</span> <span class="n">yTemp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">+</span> <span class="mf">0.</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mf">0.</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="mf">0.</span>
        <span class="n">DTemp</span><span class="p">,</span> <span class="n">CTemp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">+</span> <span class="mf">0.</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span> <span class="o">+</span> <span class="mf">0.</span>
        <span class="n">sTemp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span> <span class="o">+</span> <span class="mf">0.</span>
        <span class="c1">#  Make a vector of the variables</span>
        <span class="n">U1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">thetaTemp</span><span class="p">,</span> <span class="n">gammaTemp</span><span class="p">,</span> <span class="n">xTemp</span><span class="p">,</span> <span class="n">yTemp</span><span class="p">,</span> <span class="n">DTemp</span><span class="p">,</span> <span class="n">CTemp</span><span class="p">])</span>

        <span class="c1"># Tell the solver not to add nodes</span>
        <span class="n">maxNodes</span> <span class="o">=</span> <span class="n">xTemp</span><span class="o">.</span><span class="n">size</span>

        <span class="c1"># sTemp must be strictly increasing, so enforce that if it isn&#39;t</span>
        <span class="n">checker</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sTemp</span><span class="p">,</span> <span class="n">sTemp</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">checker</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;s is not striclty increasing. Forcing monotonicity&quot;</span><span class="p">,</span> <span class="nb">object</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">vals</span><span class="p">,</span> <span class="n">idx_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sTemp</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># sets of indices</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">sTemp</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">idx_start</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="c1"># filter them with respect to their size, keeping only items occurring more than once</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">res</span><span class="p">))</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="c1"># Get consecutive values and remove them</span>
            <span class="n">grouped_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Ungroup and every second element of consecutive numbers</span>
            <span class="n">indices_to_add_to</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">grouped_idxs</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">[::</span><span class="mi">2</span><span class="p">]]</span>

            <span class="c1"># Alter s</span>
            <span class="n">sTemp</span><span class="p">[</span><span class="n">indices_to_add_to</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">1e-6</span>

            <span class="c1"># check again</span>
            <span class="n">checker</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sTemp</span><span class="p">,</span> <span class="n">sTemp</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>

        <span class="c1"># Solve the BVP using Scipy</span>
        <span class="n">sol1</span> <span class="o">=</span> <span class="n">solve_bvp_scipy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">funcForScipyBVPSolver</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bvp_bcs</span><span class="p">,</span> <span class="n">sTemp</span><span class="p">,</span> <span class="n">U1</span><span class="p">,</span> <span class="n">max_nodes</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">maxNodes</span><span class="p">),</span>
                               <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">relax_tol</span><span class="p">)</span>

        <span class="c1"># Check if the sol1ver passed</span>
        <span class="k">if</span> <span class="n">sol1</span><span class="o">.</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;WARNING: sol1.status is </span><span class="si">%d</span><span class="s2"> for cell </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sol1</span><span class="o">.</span><span class="n">status</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="p">))</span>

        <span class="c1"># Update the cortex variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">sol1</span><span class="o">.</span><span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">sol1</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">sol1</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sol1</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">sol1</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="n">sol1</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">sol1</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="o">.</span><span class="n">size</span>

        <span class="c1"># If the solver added nodes, just remove them (but we hard code it not to now)</span>
        <span class="k">if</span> <span class="n">sTemp</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">sol1</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="n">indices_to_keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">sol1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">sTemp</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="n">indices_to_keep</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">[</span><span class="n">indices_to_keep</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">[</span><span class="n">indices_to_keep</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">indices_to_keep</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">indices_to_keep</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">[</span><span class="n">indices_to_keep</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">indices_to_keep</span><span class="p">]</span>

            <span class="c1"># If above failed, just return what we put in</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sTemp</span><span class="p">):</span>  <span class="c1"># or sol1.status != 0:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">sTemp</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">thetaTemp</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">gammaTemp</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">xTemp</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">yTemp</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="n">CTemp</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="n">DTemp</span>

        <span class="c1"># Unnecessary code lingering from previous iteration</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">decimateAbove</span><span class="p">:</span>
            <span class="n">new_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest_len</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">decimateAbove</span><span class="p">)</span>
            <span class="c1"># Update variables</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate_variable_onto_new_grid</span><span class="p">(</span><span class="n">sol1</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sol1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">new_s</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate_variable_onto_new_grid</span><span class="p">(</span><span class="n">sol1</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sol1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">new_s</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate_variable_onto_new_grid</span><span class="p">(</span><span class="n">sol1</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">sol1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">new_s</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate_variable_onto_new_grid</span><span class="p">(</span><span class="n">sol1</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">sol1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">new_s</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate_variable_onto_new_grid</span><span class="p">(</span><span class="n">sol1</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">sol1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">new_s</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate_variable_onto_new_grid</span><span class="p">(</span><span class="n">sol1</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">sol1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">new_s</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decimateAbove</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">new_s</span>

        <span class="c1"># store status of last solve</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_solve_status</span> <span class="o">=</span> <span class="n">sol1</span><span class="o">.</span><span class="n">status</span>

        <span class="k">return</span> <span class="n">sol1</span><span class="o">.</span><span class="n">status</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">]</span></div>


<div class="viewcode-block" id="Cell.get_normal_and_tangential_components_of_cortex_forces"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.get_normal_and_tangential_components_of_cortex_forces">[docs]</a>    <span class="k">def</span> <span class="nf">get_normal_and_tangential_components_of_cortex_forces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get normal and tangential components of force gradient exerted by cortex.</span>
<span class="sd">        This is sum of adhesion and pressure in equilibrium</span>

<span class="sd">        :return:  Cortex forces in the normal and tangential directions</span>
<span class="sd">        :rtype: (np.array, np.array)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get adhesion forces</span>
        <span class="n">ad_forces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_total_adhesion_force_across_cortex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">)</span>

        <span class="c1"># Normal and tangential dirs</span>
        <span class="n">normal</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)]</span>
        <span class="n">tangent</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)]</span>
        <span class="n">gradOmegaDotN</span> <span class="o">=</span> <span class="p">(</span><span class="n">ad_forces</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">normal</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">gradOmegaDotT</span> <span class="o">=</span> <span class="p">(</span><span class="n">ad_forces</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">tangent</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Pressure forces:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pressure_on_off</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">area_stiffness</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">pressure</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c1"># pressure = self.pressure</span>
            <span class="n">pressure</span> <span class="o">=</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">area_stiffness</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_area</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pref_area</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">pressure</span>

            <span class="c1"># Get the ids of the nearest/most common cortex</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="p">[</span>
                <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="n">Counter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections_identities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">else</span> <span class="s1">&#39;none&#39;</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>

            <span class="c1"># Scale medial with adhesion density</span>
            <span class="n">pressure_scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">val</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_density_dict</span><span class="p">[</span><span class="n">val</span><span class="p">],</span> <span class="n">ids</span><span class="p">)))</span>
            <span class="c1"># Remove pressure force if there are no cadherins</span>
            <span class="n">pressure_scale</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ad_forces</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">pressure_scale</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="n">spacing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_xy_segment_lengths</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

            <span class="n">total_pressure</span> <span class="o">=</span> <span class="n">pressure</span> <span class="o">*</span> <span class="n">pressure_scale</span> <span class="o">*</span> <span class="n">spacing</span>

            <span class="c1"># Add pressure to normal force</span>
            <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">gradOmegaDotN</span><span class="p">,</span> <span class="n">total_pressure</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;unsafe&#39;</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">gradOmegaDotN</span><span class="p">)</span>

        <span class="n">f_t</span> <span class="o">=</span> <span class="o">-</span><span class="n">gradOmegaDotT</span>
        <span class="n">f_n</span> <span class="o">=</span> <span class="o">-</span><span class="n">gradOmegaDotN</span>

        <span class="k">return</span> <span class="n">f_n</span><span class="p">,</span> <span class="n">f_t</span></div>


<div class="viewcode-block" id="Cell.get_cortex_forces"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.get_cortex_forces">[docs]</a>    <span class="k">def</span> <span class="nf">get_cortex_forces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the total forces exerted by the cortex (against adhesion), summed of normal and tang dirs.</span>

<span class="sd">        :return:  Total force acting across cortex.</span>
<span class="sd">        :rtype:  np.array</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Components of force gradient</span>
        <span class="n">f_n</span><span class="p">,</span> <span class="n">f_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_normal_and_tangential_components_of_cortex_forces</span><span class="p">()</span>

        <span class="c1"># Normal and tangential dirs</span>
        <span class="n">normal</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)]</span>
        <span class="n">tangent</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)]</span>

        <span class="c1"># Forces</span>
        <span class="n">normal_forces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">f_n</span><span class="p">)</span>
        <span class="n">tangential_forces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">tangent</span><span class="p">,</span> <span class="n">f_t</span><span class="p">)</span>

        <span class="c1"># Total force:</span>
        <span class="n">total_forces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">normal_forces</span><span class="p">,</span> <span class="n">tangential_forces</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">total_forces</span></div>


<div class="viewcode-block" id="Cell.get_stress_tensor"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.get_stress_tensor">[docs]</a>    <span class="k">def</span> <span class="nf">get_stress_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate cell stress tensor</span>

<span class="sd">        :return:  The 2x2 stress tensor</span>
<span class="sd">        :rtype:  np.array</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Total force:</span>
        <span class="n">total_forces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cortex_forces</span><span class="p">()</span>

        <span class="c1"># Centroid</span>
        <span class="n">centroid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_centroid</span><span class="p">()</span>

        <span class="c1"># Get the stress tensor</span>
        <span class="n">stress</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="n">r_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>  <span class="c1"># - centroid</span>
            <span class="n">stress</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">r_vector</span><span class="p">,</span> <span class="n">total_forces</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="n">stress</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_area</span><span class="p">()</span>
        <span class="n">stress</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">stress</span> <span class="o">+</span> <span class="n">stress</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>  <span class="c1"># Enforce symmetric</span>

        <span class="k">return</span> <span class="n">stress</span></div>


<div class="viewcode-block" id="Cell.get_effective_pressure"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.get_effective_pressure">[docs]</a>    <span class="k">def</span> <span class="nf">get_effective_pressure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Isotropic part of cell-level stress</span>

<span class="sd">        :return:  Trace of the stress tensor</span>
<span class="sd">        :rtype:  float</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stress_tensor</span><span class="p">()</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span></div>


<div class="viewcode-block" id="Cell.get_shape_tensor"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.get_shape_tensor">[docs]</a>    <span class="k">def</span> <span class="nf">get_shape_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get cell shape tensor</span>

<span class="sd">        :return:  2x2 shape tensor.</span>
<span class="sd">        :rtype:  np.array</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Centroid</span>
        <span class="n">centroid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)])</span>

        <span class="c1"># Get the stress tensor</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="n">r_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>  <span class="c1"># - centroid</span>
            <span class="n">shape</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">r_vector</span><span class="p">,</span> <span class="n">r_vector</span><span class="p">)</span>

        <span class="n">shape</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_area</span><span class="p">()</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">shape</span> <span class="o">+</span> <span class="n">shape</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">shape</span></div>


<div class="viewcode-block" id="Cell.double_mesh"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.double_mesh">[docs]</a>    <span class="k">def</span> <span class="nf">double_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;put new mesh points at mean locations of current&quot;&quot;&quot;</span>

        <span class="n">mean_s</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">mean_s</span><span class="p">)</span>

        <span class="n">mean_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">mean_x</span><span class="p">)</span>

        <span class="n">mean_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">mean_y</span><span class="p">)</span>

        <span class="n">mean_theta</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">mean_theta</span><span class="p">)</span>

        <span class="n">mean_gamma</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">mean_gamma</span><span class="p">)</span>

        <span class="n">mean_C</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">mean_C</span><span class="p">)</span>

        <span class="n">mean_D</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">mean_D</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="o">.</span><span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decimateAbove</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">*</span> <span class="mf">1.1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_reference_configuration_to_current</span><span class="p">()</span></div>


<div class="viewcode-block" id="Cell.adaptive_mesh_update"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.adaptive_mesh_update">[docs]</a>    <span class="k">def</span> <span class="nf">adaptive_mesh_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coarsen</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">refine</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nodes_to_keep</span><span class="o">=</span><span class="nb">set</span><span class="p">()):</span>
        <span class="sd">&quot;&quot;&quot;refine and coarsen mesh based on curvature</span>

<span class="sd">        :param coarsen:  (Default value = True) Whether to apply coarsening by removing nodes.</span>
<span class="sd">        :type coarsen:  bool</span>
<span class="sd">        :param refine:  (Default value = True)  Whether to apply refinement by adding nodes.</span>
<span class="sd">        :type refine:  bool</span>
<span class="sd">        :param nodes_to_keep:  (Default value = set())  A list of nodes that cannot be removed.</span>
<span class="sd">        :type nodes_to_keep:  set</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Adapting mesh&quot;</span><span class="p">,</span> <span class="nb">object</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">refine</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">refine_mesh</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">coarsen</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coarsen_mesh</span><span class="p">(</span><span class="n">nodes_to_keep</span><span class="o">=</span><span class="n">nodes_to_keep</span><span class="p">)</span>

        <span class="c1"># self.get_mesh_spacing()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_deformed_mesh_spacing</span><span class="p">()</span></div>


<div class="viewcode-block" id="Cell.refine_mesh"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.refine_mesh">[docs]</a>    <span class="k">def</span> <span class="nf">refine_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;spacing&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Refine the mesh by adding nodes in regions of high curvature or low spacing</span>

<span class="sd">        :param method:  (Default value = &#39;spacing&#39;)  Method to use. Add mesh nodes based on their spacing or curvature.</span>
<span class="sd">        :type method:  string</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Refining mesh&quot;</span><span class="p">,</span> <span class="nb">object</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">done</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">done</span><span class="p">:</span>

            <span class="c1"># Get the lengths of the elements</span>
            <span class="n">spacing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mesh_spacing</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;spacing&#39;</span><span class="p">:</span>
                <span class="n">max_spacing</span> <span class="o">=</span> <span class="mf">0.25</span>
                <span class="c1"># find the nodes with low density</span>
                <span class="n">sparse_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">spacing</span> <span class="o">&gt;</span> <span class="n">max_spacing</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">sparse_idxs</span> <span class="o">=</span> <span class="n">sparse_idxs</span><span class="p">[</span><span class="n">sparse_idxs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">sparse_idxs</span> <span class="o">=</span> <span class="n">sparse_idxs</span><span class="p">[</span><span class="n">sparse_idxs</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;curvature&#39;</span><span class="p">:</span>
                <span class="c1"># max_curvature = 1/50.</span>
                <span class="n">max_curvature</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span> <span class="o">*</span> <span class="mi">2000</span>  <span class="c1">#\todo make this self.s.size</span>
                <span class="n">max_curv_density</span> <span class="o">=</span> <span class="n">max_curvature</span> <span class="o">*</span> <span class="mf">0.1329</span>  <span class="c1"># (.1329 = 2658 / 2000; original circle len / 2000)</span>

                <span class="c1"># find the nodes with high curvature density</span>
                <span class="n">sparse_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span> <span class="o">*</span> <span class="n">spacing</span> <span class="o">&gt;</span> <span class="n">max_curv_density</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">sparse_idxs</span> <span class="o">=</span> <span class="n">sparse_idxs</span><span class="p">[</span><span class="n">sparse_idxs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">sparse_idxs</span> <span class="o">=</span> <span class="n">sparse_idxs</span><span class="p">[</span><span class="n">sparse_idxs</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Insert new nodes before all that were not dense enough</span>
            <span class="c1"># S</span>
            <span class="n">mean_s</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sparse_idxs</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">sparse_idxs</span><span class="p">,</span> <span class="n">mean_s</span><span class="p">)</span>
            <span class="c1"># theta</span>
            <span class="n">mean_thetas</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sparse_idxs</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span> <span class="n">sparse_idxs</span><span class="p">,</span> <span class="n">mean_thetas</span><span class="p">)</span>
            <span class="c1"># gamma</span>
            <span class="n">mean_gammas</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sparse_idxs</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">,</span> <span class="n">sparse_idxs</span><span class="p">,</span> <span class="n">mean_gammas</span><span class="p">)</span>
            <span class="c1"># x</span>
            <span class="n">mean_xs</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sparse_idxs</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">sparse_idxs</span><span class="p">,</span> <span class="n">mean_xs</span><span class="p">)</span>
            <span class="c1"># y</span>
            <span class="n">mean_ys</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sparse_idxs</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">sparse_idxs</span><span class="p">,</span> <span class="n">mean_ys</span><span class="p">)</span>
            <span class="c1"># c</span>
            <span class="n">mean_cs</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sparse_idxs</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">,</span> <span class="n">sparse_idxs</span><span class="p">,</span> <span class="n">mean_cs</span><span class="p">)</span>
            <span class="c1"># d</span>
            <span class="n">mean_ds</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sparse_idxs</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="n">sparse_idxs</span><span class="p">,</span> <span class="n">mean_ds</span><span class="p">)</span>

            <span class="c1"># Update the Lagrange trackers</span>
            <span class="n">largest_val</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lagrangian_point_ids</span><span class="p">)</span>
            <span class="n">additional_trackers</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">largest_val</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lagrangian_point_ids</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">sparse_idxs</span><span class="p">))]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lagrangian_point_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lagrangian_point_ids</span><span class="p">,</span> <span class="n">sparse_idxs</span><span class="p">,</span> <span class="n">additional_trackers</span><span class="p">)</span>

            <span class="c1"># n</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="o">.</span><span class="n">size</span>

            <span class="c1"># Don&#39;t loop as that can break the lagrange tracking.</span>
            <span class="n">done</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Decimate above</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decimateAbove</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">*</span> <span class="mf">1.1</span></div>


<div class="viewcode-block" id="Cell.coarsen_mesh"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.coarsen_mesh">[docs]</a>    <span class="k">def</span> <span class="nf">coarsen_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;spacing&#39;</span><span class="p">,</span> <span class="n">nodes_to_keep</span><span class="o">=</span><span class="nb">set</span><span class="p">()):</span>
        <span class="sd">&quot;&quot;&quot;Removes nodes in the mesh that are no longer needed.</span>

<span class="sd">        :param method:  (Default value = &#39;spacing&#39;)  Method to determine which nodes are removed.  spacing or curvature</span>
<span class="sd">        :type method:  string</span>
<span class="sd">        :param nodes_to_keep:  (Default value = set())  A set of nodes that can&#39;t be removed.</span>
<span class="sd">        :type nodes_to_keep:  set</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Coarsening mesh&quot;</span><span class="p">,</span> <span class="nb">object</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">keep_going</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">while</span> <span class="n">keep_going</span><span class="p">:</span>
            <span class="c1"># Get the lengths of cortex elements</span>
            <span class="n">spacing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mesh_spacing</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;spacing&#39;</span><span class="p">:</span>
                <span class="c1"># Maximum node spacing.</span>
                <span class="n">max_spacing</span> <span class="o">=</span> <span class="mf">0.1</span>  <span class="c1"># 0.05</span>

                <span class="c1"># find the nodes with high density (note threshold is different to above)</span>
                <span class="c1"># Only include nodes that have sufficiently dense spacing</span>
                <span class="n">indices_to_remove</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">spacing</span> <span class="o">&lt;</span> <span class="n">max_spacing</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;curvature&#39;</span><span class="p">:</span>
                <span class="c1"># Maximum node spacing.</span>
                <span class="n">max_spacing</span> <span class="o">=</span> <span class="mf">0.1329</span>

                <span class="c1"># min_curvature = .1 / 50.</span>
                <span class="n">min_curvature</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span> <span class="o">*</span> <span class="mi">20</span>
                <span class="n">min_curv_density</span> <span class="o">=</span> <span class="n">min_curvature</span> <span class="o">*</span> <span class="n">max_spacing</span>

                <span class="c1"># find the nodes with low curvature density (note threshold is different to above)</span>
                <span class="c1"># Only include nodes that have sufficiently dense spacing</span>
                <span class="n">indices_to_remove</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span> <span class="o">*</span> <span class="n">spacing</span> <span class="o">&lt;</span> <span class="n">min_curv_density</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">spacing</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">max_spacing</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Kepp specified indices</span>
            <span class="n">indices_to_remove</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indices_to_remove</span> <span class="k">if</span> <span class="n">idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nodes_to_keep</span><span class="p">]</span>

            <span class="c1"># Now remove every element that comes in sequence (i = (i-1_ + 1)) so we don&#39;t create large gaps.</span>
            <span class="c1"># Group consecutive streams</span>
            <span class="n">grouped_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">indices_to_remove</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">indices_to_remove</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Ungroup and every second element of consecutive numbers</span>
            <span class="n">indices_to_remove</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">grouped_idxs</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span> <span class="k">if</span>
                                 <span class="n">val</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">val</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Make sure don&#39;t remove too many at once</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices_to_remove</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_mesh_coarsen_fraction</span><span class="p">:</span>
                <span class="n">keep_going</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">number_of_ads_to_pick</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_mesh_coarsen_fraction</span><span class="p">)</span>
                <span class="n">prob_of_removal</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">spacing</span><span class="p">[</span><span class="n">indices_to_remove</span><span class="p">]</span>
                <span class="n">prob_of_removal</span> <span class="o">/=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">prob_of_removal</span><span class="p">)</span>
                <span class="n">indices_to_remove</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">indices_to_remove</span><span class="p">,</span> <span class="n">number_of_ads_to_pick</span><span class="p">,</span>
                                                     <span class="n">p</span><span class="o">=</span><span class="n">prob_of_removal</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices_to_remove</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">keep_going</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Filter all indices by the ones to remove</span>
            <span class="n">indices_to_keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
            <span class="n">indices_to_keep</span> <span class="o">=</span> <span class="n">indices_to_keep</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">indices_to_keep</span><span class="p">,</span> <span class="n">indices_to_remove</span><span class="p">)]</span>

            <span class="c1"># Make sure the boundary nodes are kept</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">indices_to_keep</span><span class="p">:</span>
                <span class="n">indices_to_keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">indices_to_keep</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">indices_to_keep</span><span class="p">:</span>
                <span class="n">indices_to_keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">indices_to_keep</span><span class="p">,</span> <span class="n">indices_to_keep</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Remove nodes that are on straight curves.</span>
            <span class="c1"># S</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="n">indices_to_keep</span><span class="p">]</span>
            <span class="c1"># theta</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">[</span><span class="n">indices_to_keep</span><span class="p">]</span>
            <span class="c1"># gamma</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">[</span><span class="n">indices_to_keep</span><span class="p">]</span>
            <span class="c1"># x</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">indices_to_keep</span><span class="p">]</span>
            <span class="c1"># y</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">indices_to_keep</span><span class="p">]</span>
            <span class="c1"># c</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">[</span><span class="n">indices_to_keep</span><span class="p">]</span>
            <span class="c1"># d</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">indices_to_keep</span><span class="p">]</span>
            <span class="c1"># Lagrange trackers</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lagrangian_point_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lagrangian_point_ids</span><span class="p">[</span><span class="n">indices_to_keep</span><span class="p">]</span>

            <span class="c1"># n</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="o">.</span><span class="n">size</span>

            <span class="c1"># Decimate above</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">decimateAbove</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">*</span> <span class="mf">1.1</span>

            <span class="n">keep_going</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># \TODO indices to remove change after initial pruning so can&#39;t loop atm.</span></div>


<div class="viewcode-block" id="Cell.get_mesh_spacing"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.get_mesh_spacing">[docs]</a>    <span class="k">def</span> <span class="nf">get_mesh_spacing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the spacing between nodes in the undeformed configuration</span>

<span class="sd">        :return:  The current undeformed mesh spacing</span>
<span class="sd">        :rtype:  np.array</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span>

        <span class="n">spacing</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">spacing</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">spacing</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spacing</span><span class="p">)</span></div>


<div class="viewcode-block" id="Cell.update_deformed_mesh_spacing"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.update_deformed_mesh_spacing">[docs]</a>    <span class="k">def</span> <span class="nf">update_deformed_mesh_spacing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the spacing between mesh nodes in the deformed configuration</span>

<span class="sd">        :param x:  (Default value = None)  x-coordinates to use.  Defaults to stored cortex x variable.</span>
<span class="sd">        :type x:  np.array</span>
<span class="sd">        :param y:  (Default value = None) y-coordinates to use.  Defaults to stored cortex y variable.</span>
<span class="sd">        :type y:  np.array</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">deformed_mesh_spacing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_xy_segment_lengths</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">deformed_mesh_spacing</span></div>


<div class="viewcode-block" id="Cell.get_xy_segment_lengths"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.get_xy_segment_lengths">[docs]</a>    <span class="k">def</span> <span class="nf">get_xy_segment_lengths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param x:  (Default value = None)  x-coordinates to use.  Defaults to stored cortex x variable.</span>
<span class="sd">        :type x:  np.array</span>
<span class="sd">        :param y:  (Default value = None) y-coordinates to use.  Defaults to stored cortex y variable.</span>
<span class="sd">        :type y:  np.array</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_xy_segment_lengths</span><span class="o">.</span><span class="vm">__defaults__</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">y</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_xy_segment_lengths</span><span class="o">.</span><span class="vm">__defaults__</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span>

        <span class="c1"># spacing = [0.5 * geom.LineString(np.dstack((x[i - 1:i + 2], y[i - 1:i + 2]))[0]).length \</span>
        <span class="c1">#            for i in range(1, x.size)]</span>
        <span class="c1"># spacing.insert(0, 0.5 * geom.LineString(np.dstack((x[0:2], y[0:2]))[0]).length)</span>

        <span class="n">spacing</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span>
                          <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
                   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">spacing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">spacing</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">spacing</span></div>

<div class="viewcode-block" id="Cell.smooth_variables"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.smooth_variables">[docs]</a>    <span class="k">def</span> <span class="nf">smooth_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fac</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">poly_order</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply a savgol filter to smooth the cortex variables</span>

<span class="sd">        :param fac:  (Default value = 40)  Factor to determine window size, = num_nodes / fac, for smoothing.</span>
<span class="sd">        :type fac:  int</span>
<span class="sd">        :param poly_order:  (Default value = 1)  Order of polynomial used for smoothing.</span>
<span class="sd">        :type poly_order:  int</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">window</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">/</span> <span class="n">fac</span><span class="p">)</span> <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">/</span> <span class="n">fac</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">/</span> <span class="n">fac</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">savgol_filter</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">),</span> <span class="n">window</span><span class="p">,</span> <span class="n">poly_order</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">savgol_filter</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">),</span> <span class="n">window</span><span class="p">,</span> <span class="n">poly_order</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> \
                                     <span class="n">savgol_filter</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">),</span> <span class="n">window</span><span class="p">,</span> <span class="n">poly_order</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> \
                                     <span class="n">savgol_filter</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">),</span> <span class="n">window</span><span class="p">,</span> <span class="n">poly_order</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">edge_order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">edge_order</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="Cell.interpolate_variable_onto_new_grid"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.interpolate_variable_onto_new_grid">[docs]</a>    <span class="k">def</span> <span class="nf">interpolate_variable_onto_new_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">current_grid</span><span class="p">,</span> <span class="n">new_grid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Interpolates a given cortex variable from old_grid to new_grid</span>

<span class="sd">        :param variable: The cortex variable (or any array) to be interpolated onto a new grid..</span>
<span class="sd">        :type variable: list</span>
<span class="sd">        :param current_grid: The current undeformed mesh spacing, S_0.</span>
<span class="sd">        :type current_grid: list</span>
<span class="sd">        :param new_grid: The new mesh grid that the variable will be interpolated to.</span>
<span class="sd">        :type new_grid: list</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># interpolate on the current domain</span>
        <span class="n">var_interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">current_grid</span><span class="p">,</span> <span class="n">variable</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">var_interp</span><span class="p">(</span><span class="n">new_grid</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cell.decimate_all_variables_onto_new_grid"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.decimate_all_variables_onto_new_grid">[docs]</a>    <span class="k">def</span> <span class="nf">decimate_all_variables_onto_new_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">use_scipy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">new_s</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Change the grid and interpolate all variables onto it</span>

<span class="sd">        :param factor: Scaling factor for removing nodes.</span>
<span class="sd">        :param factor: int</span>
<span class="sd">        :param use_scipy:  (Default value = False)  Whether to use Scipy&#39;s version of the function.</span>
<span class="sd">        :param use_scipy:  bool</span>
<span class="sd">        :param new_s:  (Default value = None)  The new undeformed mesh, S_0., which the decimated grid can be interpolated onto.</span>
<span class="sd">        :param new_s:  list</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">new_s</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate_variable_onto_new_grid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">new_s</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate_variable_onto_new_grid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">new_s</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate_variable_onto_new_grid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">new_s</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate_variable_onto_new_grid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">new_s</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate_variable_onto_new_grid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">new_s</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate_variable_onto_new_grid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">new_s</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">new_s</span><span class="o">.</span><span class="n">size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">new_s</span>

        <span class="k">elif</span> <span class="n">use_scipy</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">decimate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">factor</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">decimate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span> <span class="n">factor</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">decimate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">,</span> <span class="n">factor</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">decimate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">factor</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">decimate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">factor</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="n">decimate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="n">factor</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="n">decimate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">,</span> <span class="n">factor</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="o">.</span><span class="n">size</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">[::</span><span class="n">factor</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">[::</span><span class="n">factor</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">[::</span><span class="n">factor</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[::</span><span class="n">factor</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[::</span><span class="n">factor</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[::</span><span class="n">factor</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">[::</span><span class="n">factor</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="o">.</span><span class="n">size</span></div>


<div class="viewcode-block" id="Cell.upsample_all_variables_onto_new_grid"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.upsample_all_variables_onto_new_grid">[docs]</a>    <span class="k">def</span> <span class="nf">upsample_all_variables_onto_new_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Change the grid and interpolate all variables onto it</span>

<span class="sd">        :param new_n:  The new number of discretised nodes for the cortex variabels.</span>
<span class="sd">        :type new_n: int</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">resample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">new_n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">resample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span> <span class="n">new_n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">resample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">,</span> <span class="n">new_n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">resample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">new_n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">resample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">new_n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="n">resample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="n">new_n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="n">resample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">,</span> <span class="n">new_n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">new_n</span></div>


<div class="viewcode-block" id="Cell.create_apposed_cortex"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.create_apposed_cortex">[docs]</a>    <span class="k">def</span> <span class="nf">create_apposed_cortex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates an additional cell cortex within this class.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">()</span></div>


<div class="viewcode-block" id="Cell.get_length_of_adhesions"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.get_length_of_adhesions">[docs]</a>    <span class="k">def</span> <span class="nf">get_length_of_adhesions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rerun_distance_calculation</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Get the lengths of all connected adhesions.</span>

<span class="sd">        :param rerun_distance_calculation:  (Default value = True)  Whether to re-check the lengths of adhesions.</span>
<span class="sd">        :param rerun_distance_calculation:  bool</span>
<span class="sd">        :return:  The lengths of the adhesions</span>
<span class="sd">        :rtype:  np.array</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">rerun_distance_calculation</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_adhesion_distances_identifiers_and_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">sort_by_distance</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Get the discrete points on the cortex</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Get the adhesion points</span>
        <span class="n">chosen_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="k">else</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections</span><span class="p">]</span>
        <span class="n">chosen_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">chosen_nodes</span><span class="p">)</span>

        <span class="c1"># Calculate distances</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">chosen_nodes</span> <span class="o">-</span> <span class="n">points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="Cell.get_length_of_longest_adhesion"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.get_length_of_longest_adhesion">[docs]</a>    <span class="k">def</span> <span class="nf">get_length_of_longest_adhesion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rerun_distance_calculation</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Length of the longest connected adhesion.</span>

<span class="sd">        :param rerun_distance_calculation:  (Default value = True)  Whether to update the adhesions.</span>
<span class="sd">        :param rerun_distance_calculation:  bool</span>
<span class="sd">        :return:  The length of the longest adhesion.</span>
<span class="sd">        :rtype:  float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_length_of_adhesions</span><span class="p">(</span><span class="n">rerun_distance_calculation</span><span class="o">=</span><span class="n">rerun_distance_calculation</span><span class="p">))</span></div>


<div class="viewcode-block" id="Cell.get_length_of_shortest_adhesion"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.get_length_of_shortest_adhesion">[docs]</a>    <span class="k">def</span> <span class="nf">get_length_of_shortest_adhesion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rerun_distance_calculation</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param rerun_distance_calculation:  (Default value = True)  Whether to update the adhesions.</span>
<span class="sd">        :param rerun_distance_calculation:  bool</span>
<span class="sd">        :return:  The length of the shortest adhesion.</span>
<span class="sd">        :rtype:  float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_length_of_adhesions</span><span class="p">(</span><span class="n">rerun_distance_calculation</span><span class="o">=</span><span class="n">rerun_distance_calculation</span><span class="p">))</span></div>


<div class="viewcode-block" id="Cell.get_length"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.get_length">[docs]</a>    <span class="k">def</span> <span class="nf">get_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get total length cortex</span>

<span class="sd">        :return:  The integrated deformed mesh spacing.</span>
<span class="sd">        :rtype:  float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Approximate length using shapely.</span>
        <span class="n">myLine</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">LineString</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">myLine</span><span class="o">.</span><span class="n">length</span></div>


<div class="viewcode-block" id="Cell.get_area"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.get_area">[docs]</a>    <span class="k">def</span> <span class="nf">get_area</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the signed area of the cell</span>

<span class="sd">        :param x:  (Default value = None)  x-coordinates to use.  Defaults to stored cortex x variable.</span>
<span class="sd">        :type x:  np.array</span>
<span class="sd">        :param y:  (Default value = None) y-coordinates to use.  Defaults to stored cortex y variable.</span>
<span class="sd">        :type y:  np.array</span>
<span class="sd">        :return:  The area enclosed by the cortex.</span>
<span class="sd">        :rtype:  float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span>

        <span class="c1"># Create a shapely polygon</span>
        <span class="n">cell_poly</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">cell_poly</span><span class="o">.</span><span class="n">area</span></div>


<div class="viewcode-block" id="Cell.get_centroid"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.get_centroid">[docs]</a>    <span class="k">def</span> <span class="nf">get_centroid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the perimeter-based centroid. This is important if the spacing becomes non-uniform then the</span>
<span class="sd">        mean of node positions becomes biased to where nodes are most dense.</span>

<span class="sd">        :param x:  (Default value = None)  x-coordinates to use.  Defaults to stored cortex x variable.</span>
<span class="sd">        :type x:  np.array</span>
<span class="sd">        :param y:  (Default value = None) y-coordinates to use.  Defaults to stored cortex y variable.</span>
<span class="sd">        :type y:  np.array</span>
<span class="sd">        :return:  The (x,y) coords of the centroid.</span>
<span class="sd">        :rtype:  tuple</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">x</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">y</span>

        <span class="n">spacing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_xy_segment_lengths</span><span class="p">()</span>
        <span class="n">x_spacing</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">x_spacing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_spacing</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">y_spacing</span> <span class="o">=</span> <span class="n">y</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">y_spacing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_spacing</span><span class="p">,</span> <span class="p">[</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">centroid</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x_spacing</span> <span class="o">*</span> <span class="n">spacing</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y_spacing</span> <span class="o">*</span> <span class="n">spacing</span><span class="p">)]))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_length</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">centroid</span></div>


<div class="viewcode-block" id="Cell.get_length_of_cortex_with_active_contractility"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.get_length_of_cortex_with_active_contractility">[docs]</a>    <span class="k">def</span> <span class="nf">get_length_of_cortex_with_active_contractility</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the total length of the cortex that has active contractility</span>

<span class="sd">        :return:  The summed cortex segments that have active contractility.</span>
<span class="sd">        :rtype:  float</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get the prestrain</span>
        <span class="n">prestrains</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_prestrains</span><span class="p">()</span>
        <span class="c1"># get lengths of segments</span>
        <span class="n">segments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_xy_segment_lengths</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">segments</span><span class="p">[</span><span class="n">prestrains</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">])</span></div>


<div class="viewcode-block" id="Cell.pickle_self"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.pickle_self">[docs]</a>    <span class="k">def</span> <span class="nf">pickle_self</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SAVE_DIR</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Pickles instance of this class</span>

<span class="sd">        :param SAVE_DIR:  (Default value = None)  Location to save.</span>
<span class="sd">        :type SAVE_DIR:  string</span>
<span class="sd">        :param name:  (Default value = None)  Name of the pickled file.</span>
<span class="sd">        :type name:  string</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Saving cortex </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="nb">object</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">SAVE_DIR</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">SAVE_DIR</span> <span class="o">=</span> <span class="n">CURRENT_DIR</span>
        <span class="c1"># Make sure the directory exists</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">SAVE_DIR</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">SAVE_DIR</span><span class="p">)</span>
        <span class="c1"># Filename</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;cell_&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span> <span class="o">+</span> <span class="s1">&#39;_omega0_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega0</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="s1">&#39;_pressure_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pressure</span><span class="p">)</span>

        <span class="c1"># saveloc</span>
        <span class="n">saveloc</span> <span class="o">=</span> <span class="n">SAVE_DIR</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">name</span>
        <span class="c1"># Pickle</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">saveloc</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">s</span><span class="p">:</span>
            <span class="n">dill</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span></div>


<div class="viewcode-block" id="Cell.plot_cortex_variables"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.plot_cortex_variables">[docs]</a>    <span class="k">def</span> <span class="nf">plot_cortex_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">plot_legend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">plot_strain</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Function to plot the data on 3 plot_3panels</span>

<span class="sd">        :param ax:  (Default value = None)</span>
<span class="sd">        :param linestyle:  (Default value = &#39;-&#39;)</span>
<span class="sd">        :param plot_legend:  (Default value = True)</span>
<span class="sd">        :param plot_strain:  (Default value = False)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Plotting cortex variables for cell </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="nb">object</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">plot_strain</span><span class="p">:</span>
                <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">plot_legend</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="sa">r</span><span class="s1">&#39;$\tilde</span><span class="si">{c}</span><span class="s1">$&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;$\tilde{\gamma}$&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;$\theta$&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;$\varepsilon = \gamma-1$&#39;</span><span class="p">,</span>
                      <span class="sa">r</span><span class="s1">&#39;$\gamma$&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">]</span>

        <span class="c1"># Get the prestrains</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adhesion_point_coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">),</span> \
            <span class="s2">&quot;Error, must &#39;update_adhesion_points_between_all_cortices&#39; on eptm.&quot;</span>
        <span class="n">prestrain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_prestrains</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">plot_strain</span><span class="p">:</span>
            <span class="n">tau</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">/</span> <span class="n">prestrain</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="n">linestyle</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C3&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$\tilde</span><span class="si">{c}</span><span class="s1">^\prime$&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">,</span> <span class="n">linestyle</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C0&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">linestyle</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$\tau$&#39;</span><span class="p">)</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
            <span class="n">angles</span><span class="p">[</span><span class="n">angles</span> <span class="o">&gt;</span> <span class="mi">180</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">180</span>
            <span class="n">angles</span><span class="p">[</span><span class="n">angles</span> <span class="o">&gt;</span> <span class="mi">90</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">90</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">angles</span> <span class="o">/</span> <span class="mi">100</span><span class="p">,</span> <span class="n">linestyle</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C2&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">labels</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="n">box</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_position</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_position</span><span class="p">([</span><span class="n">box</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span> <span class="n">box</span><span class="o">.</span><span class="n">y0</span><span class="p">,</span> <span class="n">box</span><span class="o">.</span><span class="n">width</span> <span class="o">*</span> <span class="mf">0.8</span><span class="p">,</span> <span class="n">box</span><span class="o">.</span><span class="n">height</span><span class="p">])</span>
            <span class="c1"># Put a legend to the right of the current axis</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;center left&#39;</span><span class="p">,</span> <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ax[0].plot(self.s, np.gradient(self.theta, self.s, edge_order=2), linestyle, color=&#39;C4&#39;, label=&quot;test&quot;)</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="n">linestyle</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C3&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$\tilde</span><span class="si">{c}</span><span class="s1">^\prime$&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">,</span> <span class="n">linestyle</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C0&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">prestrain</span><span class="p">,</span> <span class="n">linestyle</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C1&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">labels</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span><span class="p">,</span> <span class="n">linestyle</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C2&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">labels</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="n">box</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_position</span><span class="p">()</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_position</span><span class="p">([</span><span class="n">box</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span> <span class="n">box</span><span class="o">.</span><span class="n">y0</span><span class="p">,</span> <span class="n">box</span><span class="o">.</span><span class="n">width</span> <span class="o">*</span> <span class="mf">0.8</span><span class="p">,</span> <span class="n">box</span><span class="o">.</span><span class="n">height</span><span class="p">])</span>
            <span class="c1"># Put a legend to the right of the current axis</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;center left&#39;</span><span class="p">,</span> <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))</span>

            <span class="c1"># Get gamma</span>
            <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_prestrains</span><span class="p">()</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">g</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">linestyle</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C3&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">labels</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">linestyle</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C4&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">labels</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\tilde</span><span class="si">{S}</span><span class="s1">$&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="n">box</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_position</span><span class="p">()</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_position</span><span class="p">([</span><span class="n">box</span><span class="o">.</span><span class="n">x0</span><span class="p">,</span> <span class="n">box</span><span class="o">.</span><span class="n">y0</span><span class="p">,</span> <span class="n">box</span><span class="o">.</span><span class="n">width</span> <span class="o">*</span> <span class="mf">0.8</span><span class="p">,</span> <span class="n">box</span><span class="o">.</span><span class="n">height</span><span class="p">])</span>
            <span class="c1"># Put a legend to the right of the current axis</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;center left&#39;</span><span class="p">,</span> <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))</span></div>


<div class="viewcode-block" id="Cell.plot_xy_on_trijunction"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.plot_xy_on_trijunction">[docs]</a>    <span class="k">def</span> <span class="nf">plot_xy_on_trijunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">equalAx</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">plotAdhesion</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">cortexwidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">plot_adhesion_forces</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">plot_adhesion_at_specific_locations</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="n">lagrangian_tracking</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_pressure</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_tension</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plot_stress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_stress_axis</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sim_type</span><span class="o">=</span><span class="s1">&#39;single&#39;</span><span class="p">,</span>
                               <span class="n">plot_shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">label_size</span><span class="o">=</span><span class="mi">26</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot the ys x for the junction and reflect/rotate if necessary.</span>

<span class="sd">        :param ax:  (Default value = None)</span>
<span class="sd">        :param col:  (Default value = &#39;k&#39;)</span>
<span class="sd">        :param equalAx:  (Default value = True)</span>
<span class="sd">        :param plotAdhesion:  (Default value = True)</span>
<span class="sd">        :param cortexwidth:  (Default value = 2)</span>
<span class="sd">        :param plot_adhesion_forces:  (Default value = True)</span>
<span class="sd">        :param plot_adhesion_at_specific_locations:  (Default value = False)</span>
<span class="sd">        :param lagrangian_tracking:  (Default value = False)</span>
<span class="sd">        :param plot_pressure:  (Default value = False)</span>
<span class="sd">        :param plot_tension:  (Default value = False)</span>
<span class="sd">        :param label:  (Default value = None)</span>
<span class="sd">        :param plot_stress:  (Default value = False)</span>
<span class="sd">        :param plot_stress_axis:  (Default value = False)</span>
<span class="sd">        :param sim_type:  (Default value = &#39;single&#39;)</span>
<span class="sd">        :param plot_shape:  (Default value = False)</span>
<span class="sd">        :param label_size:  (Default value = 26)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span>

        <span class="c1"># fill the bulk:</span>
        <span class="k">if</span> <span class="n">plot_stress</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_stress</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">plot_stress_axis</span><span class="o">=</span><span class="n">plot_stress_axis</span><span class="p">,</span> <span class="n">sim_type</span><span class="o">=</span><span class="n">sim_type</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">plot_pressure</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_medial_pressure</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># col = &#39;C0&#39;</span>
            <span class="n">face_alpha</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">col</span> <span class="o">==</span> <span class="s2">&quot;white&quot;</span> <span class="k">else</span> <span class="o">.</span><span class="mi">2</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">face_alpha</span><span class="p">)</span>

        <span class="c1"># cell outline:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_cortex</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">plot_tension</span><span class="o">=</span><span class="n">plot_tension</span><span class="p">,</span> <span class="n">cortex_width</span><span class="o">=</span><span class="n">cortexwidth</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="n">col</span><span class="p">)</span>

        <span class="c1"># Principal axes of shape</span>
        <span class="k">if</span> <span class="n">plot_shape</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_principal_axes_of_shape</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

        <span class="c1"># Adhesions</span>
        <span class="k">if</span> <span class="n">plotAdhesion</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_adhesion_points</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">plot_forces</span><span class="o">=</span><span class="n">plot_adhesion_forces</span><span class="p">,</span>
                                      <span class="n">plot_adhesion_at_specific_locations</span><span class="o">=</span><span class="n">plot_adhesion_at_specific_locations</span><span class="p">)</span>

        <span class="c1"># Protrusion</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">protrusion_force</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_protrusion_force</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">colour</span><span class="o">=</span><span class="n">col</span><span class="p">)</span>

        <span class="c1"># Lagrangian points</span>
        <span class="k">if</span> <span class="n">lagrangian_tracking</span><span class="p">:</span>
            <span class="c1"># Scale the colour of the cortex to make slightly darker lagrangian points</span>
            <span class="n">col_scale</span> <span class="o">=</span> <span class="mf">0.75</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">cnames</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">col</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">colorsys</span><span class="o">.</span><span class="n">rgb_to_hls</span><span class="p">(</span><span class="o">*</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">to_rgb</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">colorsys</span><span class="o">.</span><span class="n">hls_to_rgb</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">col_scale</span> <span class="o">*</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="c1"># Plot</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[::</span><span class="mi">20</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[::</span><span class="mi">20</span><span class="p">],</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="n">cortexwidth</span><span class="p">))</span>

        <span class="c1"># Plot the cell label</span>
        <span class="n">label</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;$\mathcal{</span><span class="si">%s</span><span class="s1">}$&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span> <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">label</span>
        <span class="n">xshift</span> <span class="o">=</span> <span class="mi">5</span> <span class="k">if</span> <span class="n">plot_stress_axis</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">yshift</span> <span class="o">=</span> <span class="mi">10</span> <span class="k">if</span> <span class="n">plot_stress_axis</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">centroid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_centroid</span><span class="p">()</span>
        <span class="n">label_pos</span> <span class="o">=</span> <span class="n">centroid</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">plot_stress</span> \
            <span class="k">else</span> <span class="p">[</span><span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">xshift</span><span class="p">,</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">yshift</span><span class="p">]</span>
        <span class="n">kw</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">xycoords</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">label_size</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="n">label_pos</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

        <span class="c1"># Axes limits</span>
        <span class="n">minX</span><span class="p">,</span> <span class="n">maxX</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_xlim</span><span class="p">()</span>
        <span class="n">minY</span><span class="p">,</span> <span class="n">maxY</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()</span>
        <span class="n">minY</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="o">.</span><span class="mi">1</span> <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="o">.</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">minY</span> <span class="k">else</span> <span class="n">minY</span>
        <span class="n">maxY</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="o">.</span><span class="mi">1</span> <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="o">.</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">maxY</span> <span class="k">else</span> <span class="n">maxY</span>
        <span class="n">minX</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="o">.</span><span class="mi">1</span> <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="o">.</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">minX</span> <span class="k">else</span> <span class="n">minX</span>
        <span class="n">maxX</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="o">.</span><span class="mi">1</span> <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="o">.</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">maxX</span> <span class="k">else</span> <span class="n">maxX</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="n">minX</span><span class="p">,</span> <span class="n">maxX</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="n">minY</span><span class="p">,</span> <span class="n">maxY</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">equalAx</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">,</span> <span class="s1">&#39;box&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Cell.plot_cortex"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.plot_cortex">[docs]</a>    <span class="k">def</span> <span class="nf">plot_cortex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plot_tension</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cortex_width</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">max_strain</span> <span class="o">=</span> <span class="o">.</span><span class="mi">002</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot the cortex (outline) of the cell.</span>

<span class="sd">        :param ax:  (Default value = None)</span>
<span class="sd">        :param x:  (Default value = None)</span>
<span class="sd">        :param y:  (Default value = None)</span>
<span class="sd">        :param plot_tension:  (Default value = False)</span>
<span class="sd">        :param cortex_width:  (Default value = 2)</span>
<span class="sd">        :param col:  (Default value = &#39;k&#39;)</span>
<span class="sd">        :param max_strain:  (Default value = .002)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>

        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">x</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">y</span>

        <span class="c1"># Get the edges</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">plot_tension</span><span class="p">:</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections_identities</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_adhesion_distances_identifiers_and_indices</span><span class="p">()</span>

            <span class="c1"># Plot the strain (nondim tension) with a heatmap</span>
            <span class="n">default_cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;seismic&#39;</span><span class="p">)</span>
            <span class="n">cNorm</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=-</span><span class="n">max_strain</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">max_strain</span><span class="p">)</span>
            <span class="n">scaled_cmap</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">(</span><span class="n">norm</span><span class="o">=</span><span class="n">cNorm</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">default_cmap</span><span class="p">)</span>
            <span class="c1"># Get tangential component of force gradient</span>
            <span class="c1"># f_n, tau = self.get_normal_and_tangential_components_of_cortex_forces()</span>
            <span class="n">tau</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">colour_cmap</span> <span class="o">=</span> <span class="n">scaled_cmap</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>
            <span class="n">lc</span> <span class="o">=</span> <span class="n">LineCollection</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">colour_cmap</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="n">cortex_width</span><span class="p">)</span>

            <span class="c1"># Add the outline</span>
            <span class="k">if</span> <span class="n">cortex_width</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
                <span class="n">lc_outline</span> <span class="o">=</span> <span class="n">LineCollection</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=.</span><span class="mi">5</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">13</span><span class="p">)</span>  <span class="c1"># Centre line</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lc_outline</span> <span class="o">=</span> <span class="n">LineCollection</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="n">cortex_width</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Outline</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">lc_outline</span><span class="p">)</span>

            <span class="c1"># Plot the prestrain next to the cortex</span>
            <span class="n">prestrains</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_prestrains</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prestrains</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="o">.</span><span class="n">size</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">prestrains</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prestrains</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="n">filler</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">prestrains</span><span class="p">))</span>
                <span class="n">prestrains</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">prestrains</span><span class="p">,</span> <span class="n">filler</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">prestrains</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="n">prestrains</span> <span class="o">=</span> <span class="p">[</span><span class="n">prestrains</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
            <span class="n">stretch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prestrain_plot_offset</span>
            <span class="n">c_x</span><span class="p">,</span> <span class="n">c_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
            <span class="n">edges_myo</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">stretch</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">c_x</span><span class="p">)</span> <span class="o">+</span> <span class="n">c_x</span><span class="p">,</span> <span class="n">stretch</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">c_y</span><span class="p">)</span> <span class="o">+</span> <span class="n">c_y</span><span class="p">),</span>
                          <span class="p">(</span><span class="n">stretch</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">c_x</span><span class="p">)</span> <span class="o">+</span> <span class="n">c_x</span><span class="p">,</span> <span class="n">stretch</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">c_y</span><span class="p">)</span> <span class="o">+</span> <span class="n">c_y</span><span class="p">)]</span>
                         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">prestrains</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.9995</span><span class="p">]</span>

            <span class="n">myo_cbar_lims</span> <span class="o">=</span> <span class="mf">0.065</span> <span class="c1">#  0.01  # 0.065 for gamma = 0.94 # 0.05 old</span>
            <span class="n">cNorm_myo</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=-</span><span class="n">myo_cbar_lims</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">myo_cbar_lims</span><span class="p">)</span>
            <span class="n">scaled_cmap_myo</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">(</span><span class="n">norm</span><span class="o">=</span><span class="n">cNorm_myo</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">default_cmap</span><span class="p">)</span>
            <span class="n">myo_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">scaled_cmap_myo</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="n">pre_s</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">pre_s</span> <span class="ow">in</span> <span class="n">prestrains</span> <span class="k">if</span> <span class="n">pre_s</span> <span class="o">&lt;</span> <span class="mf">0.9995</span><span class="p">]</span>
            <span class="n">lc_myo</span> <span class="o">=</span> <span class="n">LineCollection</span><span class="p">(</span><span class="n">edges_myo</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">myo_cols</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="n">cortex_width</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">lc_myo</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Plot normal line</span>
            <span class="n">edges_col</span> <span class="o">=</span> <span class="s1">&#39;k&#39;</span> <span class="k">if</span> <span class="n">col</span> <span class="o">==</span> <span class="s1">&#39;white&#39;</span> <span class="k">else</span> <span class="n">col</span>
            <span class="n">lc</span> <span class="o">=</span> <span class="n">LineCollection</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">edges_col</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="n">cortex_width</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>

        <span class="c1"># Add the edges</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span></div>


<div class="viewcode-block" id="Cell.plot_adhesion_points"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.plot_adhesion_points">[docs]</a>    <span class="k">def</span> <span class="nf">plot_adhesion_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plot_forces</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">plot_adhesion_at_specific_locations</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot the adhesions on the cortex</span>

<span class="sd">        :param ax:  (Default value = None)</span>
<span class="sd">        :param plot_forces:  (Default value = True)</span>
<span class="sd">        :param plot_adhesion_at_specific_locations:  (Default value = False)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>

        <span class="c1"># Cell coords</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># This bit plots all fast adhesions at only certain cortex nodes</span>
        <span class="k">if</span> <span class="n">plot_adhesion_at_specific_locations</span><span class="p">:</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">500</span><span class="p">,</span> <span class="mi">1165</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">([(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">])])</span>

                <span class="n">dirs</span> <span class="o">=</span> <span class="p">[</span><span class="n">ad</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">ad</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="n">dirs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dirs</span><span class="p">)</span>
                <span class="n">dirs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">dirs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">inner1d</span><span class="p">(</span><span class="n">dirs</span><span class="p">,</span> <span class="n">dirs</span><span class="p">))[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>

                <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="nb">dir</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">dir</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="nb">dir</span> <span class="ow">in</span> <span class="n">dirs</span><span class="p">])</span>
                <span class="n">current_tangent</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])]</span>
                <span class="n">current_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">current_tangent</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">current_tangent</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                <span class="c1"># Get spring extension</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adhesion_distances</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span>
                <span class="n">force</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega0</span> <span class="o">*</span> <span class="n">e</span>

                <span class="c1"># scaling_factors_by_distance using softmax function</span>
                <span class="n">exp_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_beta_scale_factor</span>
                <span class="n">dist_scaling</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">exp_factor</span> <span class="o">*</span> <span class="n">d</span><span class="p">)</span>
                <span class="n">dist_scaling</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist_scaling</span><span class="p">)</span>
                <span class="n">force</span> <span class="o">*=</span> <span class="n">dist_scaling</span>

                <span class="n">vector_of_forces</span> <span class="o">=</span> <span class="n">dirs</span> <span class="o">*</span> <span class="n">force</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                <span class="n">vector_force</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vector_of_forces</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">vector_force</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vector_force</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.008</span><span class="p">,</span> <span class="n">scale</span><span class="o">=.</span><span class="mi">00075</span><span class="p">,</span>
                          <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">11</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dirs</span><span class="p">)):</span>
                    <span class="nb">dir</span> <span class="o">=</span> <span class="n">dirs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">force</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="mi">100000</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">dir</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dir</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.0025</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>  <span class="c1"># scale=.00010,</span>
                              <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

            <span class="n">lc</span> <span class="o">=</span> <span class="n">LineCollection</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>

        <span class="c1"># Else, we just plot the nearest fast adhesions, or slow or sdk</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">plot_forces</span><span class="p">:</span>
                <span class="n">total_force</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">get_cortex_forces</span><span class="p">()</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">total_force</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">total_force</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.0025</span><span class="p">,</span> <span class="n">scale</span><span class="o">=.</span><span class="mi">0050</span><span class="p">,</span>
                          <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fast_adhesions_active</span><span class="p">:</span>
                <span class="c1"># Get adhesion nodes</span>
                <span class="n">chosen_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">adhesion_connections</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">else</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
                <span class="c1"># Create edges</span>
                <span class="n">edges</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">chosen_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">chosen_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">])]</span>
                         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
                <span class="c1"># Colour by forces</span>
                <span class="n">forces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_total_adhesion_force_across_cortex</span><span class="p">()</span>
                <span class="n">forces</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">forces</span><span class="p">]</span>
                <span class="n">cmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_heatmap_from_array</span><span class="p">(</span><span class="n">forces</span><span class="p">)</span>
                <span class="n">lc</span> <span class="o">=</span> <span class="n">LineCollection</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>

            <span class="c1"># Slow adhesions</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slow_adhesions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">slow_ad_edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">ad</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">ad</span><span class="p">[</span><span class="mi">0</span><span class="p">]]],</span> <span class="p">[</span><span class="n">ad</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ad</span><span class="p">[</span><span class="mi">2</span><span class="p">]]])</span> <span class="k">for</span> <span class="n">ad</span> <span class="ow">in</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">slow_adhesions</span><span class="p">]</span>
                <span class="c1"># Colour by forces</span>
                <span class="n">distances</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">slow_ad_edges</span><span class="p">]</span>
                <span class="n">forces</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">omega0</span> <span class="o">*</span> <span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">distances</span><span class="p">]</span>
                <span class="n">cmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_heatmap_from_array</span><span class="p">(</span><span class="n">forces</span><span class="p">)</span>
                <span class="n">lc</span> <span class="o">=</span> <span class="n">LineCollection</span><span class="p">(</span><span class="n">slow_ad_edges</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sidekick_adhesions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Sdk adhesions</span>
                <span class="n">sdk_col</span> <span class="o">=</span> <span class="s1">&#39;#8000ff&#39;</span>
                <span class="n">sdk_lw</span> <span class="o">=</span> <span class="mf">2.5</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sidekick_adhesions</span><span class="p">):</span>
                    <span class="n">sdk_ad_edges</span> <span class="o">=</span> <span class="p">[[[</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">ad</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">ad</span><span class="p">[</span><span class="mi">0</span><span class="p">]]],</span> <span class="p">[</span><span class="n">ad</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ad</span><span class="p">[</span><span class="mi">2</span><span class="p">]]]</span> <span class="k">for</span> <span class="n">ad</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sidekick_adhesions</span><span class="p">]</span>
                    <span class="n">lc</span> <span class="o">=</span> <span class="n">LineCollection</span><span class="p">(</span><span class="n">sdk_ad_edges</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">sdk_col</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="n">sdk_lw</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cell.plot_medial_pressure"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.plot_medial_pressure">[docs]</a>    <span class="k">def</span> <span class="nf">plot_medial_pressure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot the adhesions on the cortex</span>

<span class="sd">        :param ax:  (Default value = None)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>

        <span class="n">pressure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pressure</span>

        <span class="c1"># Make a heatmap</span>
        <span class="n">max_pressure</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="n">default_cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;seismic&#39;</span><span class="p">)</span>
        <span class="n">cNorm</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=-</span><span class="n">max_pressure</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">max_pressure</span><span class="p">)</span>
        <span class="n">scaled_cmap</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">(</span><span class="n">norm</span><span class="o">=</span><span class="n">cNorm</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">default_cmap</span><span class="p">)</span>
        <span class="n">colour_cmap</span> <span class="o">=</span> <span class="n">scaled_cmap</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="n">pressure</span><span class="p">)</span>
        <span class="c1"># colour_cmap = matplotlib.cm.seismic(cNorm(self.pressure), bytes=True)</span>
        <span class="n">colour_cmap</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">to_hex</span><span class="p">(</span><span class="n">colour_cmap</span><span class="p">)</span>

        <span class="c1"># Plot the faces</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">colour_cmap</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

        <span class="c1">##########</span>

        <span class="c1"># # # Get pressure</span>
        <span class="c1"># # if self.identifier in [&#39;B&#39;, &#39;D&#39;]:</span>
        <span class="c1"># #     pressure = self.pressure</span>
        <span class="c1"># # else:</span>
        <span class="c1"># #     pressure = -self.pressure</span>
        <span class="c1"># pressure = -self.pressure</span>
        <span class="c1">#</span>
        <span class="c1"># # Figure out which ones have adhesions</span>
        <span class="c1"># # Extract the adhesion points</span>
        <span class="c1"># adhesionNodes = self.adhesion_point_coords</span>
        <span class="c1">#</span>
        <span class="c1"># # Get the discrete points on curve</span>
        <span class="c1"># slices = 20</span>
        <span class="c1"># cortex_x, cortex_y, theta = self.x[::slices], self.y[::slices], self.theta[::slices]</span>
        <span class="c1"># points = np.dstack((cortex_x, cortex_y))[0]</span>
        <span class="c1"># # Find closest distance to adhesion points</span>
        <span class="c1"># dists = cdist(points, adhesionNodes)</span>
        <span class="c1"># # #  Smallest distances:</span>
        <span class="c1"># smallestDists = [a.min() for a in dists]</span>
        <span class="c1"># smallestDists = np.array(smallestDists)</span>
        <span class="c1">#</span>
        <span class="c1"># # Get the normal</span>
        <span class="c1"># n = np.array([-np.sin(theta), np.cos(theta)]) * pressure</span>
        <span class="c1">#</span>
        <span class="c1"># # Filter only those that have actually joined. (within min dist).</span>
        <span class="c1"># n = n[:, smallestDists &lt;= self.max_adhesion_length]</span>
        <span class="c1"># xs = cortex_x[smallestDists &lt;= self.max_adhesion_length]</span>
        <span class="c1"># ys = cortex_y[smallestDists &lt;= self.max_adhesion_length]</span>
        <span class="c1">#</span>
        <span class="c1"># # # Also remove the force at the fixed boundaries</span>
        <span class="c1"># # n[0, 0:int(self.s.size / 20)] *= 0</span>
        <span class="c1"># # n[0, -int(self.s.size / 20):] *= 0</span>
        <span class="c1"># # n[1, 0:int(self.s.size / 20)] *= 0</span>
        <span class="c1"># # n[1, -int(self.s.size / 20):] *= 0</span>
        <span class="c1"># # Plot them</span>
        <span class="c1"># # Scale = 100 if scale by spacing, or 2 if not</span>
        <span class="c1"># ax.quiver(xs, ys, n[0], n[1], width=0.002, scale=.08, color=&#39;#004c00&#39;, zorder=10)</span>
        <span class="c1"># # ax.plot(np.dstack((self.x, chosen_nodes[:, 0]))[0].T,</span>
        <span class="c1"># #         np.dstack((self.y, chosen_nodes[:, 1]))[0].T, &#39;-&#39;, lw=.25, c=&#39;k&#39;)</span>

<div class="viewcode-block" id="Cell.plot_stress"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.plot_stress">[docs]</a>    <span class="k">def</span> <span class="nf">plot_stress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plot_stress_axis</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sim_type</span><span class="o">=</span><span class="s1">&#39;single&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot the adhesions on the cortex</span>

<span class="sd">        :param plot_stress_axis:  (Default value = False)</span>
<span class="sd">        :param ax:  (Default value = None)</span>
<span class="sd">        :param sim_type:  (Default value = &#39;single&#39;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>

        <span class="c1"># Get stress tensor</span>
        <span class="n">stress</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stress_tensor</span><span class="p">()</span>
        <span class="n">pressure</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">stress</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span>
        <span class="n">pressure</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># RdBu Colmap has blue for positive so just invert pressure</span>

        <span class="c1"># Make a heatmap</span>
        <span class="k">if</span> <span class="n">sim_type</span> <span class="o">==</span> <span class="s1">&#39;single&#39;</span><span class="p">:</span>
            <span class="n">max_pressure</span> <span class="o">=</span> <span class="mf">5e-4</span>  <span class="c1"># For singe junction (was 6)</span>
            <span class="n">p_axis_scale</span> <span class="o">=</span> <span class="mf">2.5e4</span>  <span class="c1">#  7.5e3  # 50000</span>
        <span class="k">elif</span> <span class="n">sim_type</span> <span class="o">==</span> <span class="s1">&#39;cable&#39;</span><span class="p">:</span>
            <span class="n">max_pressure</span> <span class="o">=</span> <span class="mf">1.2e-3</span> <span class="o">/</span> <span class="mi">1</span>  <span class="c1"># For cables</span>
            <span class="n">p_axis_scale</span> <span class="o">=</span> <span class="mf">7.5e3</span>  <span class="c1"># 20000</span>
        <span class="k">elif</span> <span class="n">sim_type</span> <span class="o">==</span> <span class="s1">&#39;whole&#39;</span><span class="p">:</span>
            <span class="n">max_pressure</span> <span class="o">=</span> <span class="mf">4e-3</span>  <span class="c1"># For whole cells</span>
            <span class="n">p_axis_scale</span> <span class="o">=</span> <span class="mf">1e1</span>  <span class="c1"># 2000</span>
        <span class="n">default_cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;RdBu&#39;</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># Truncate the colourmap to use lighter colours</span>
        <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="o">-</span><span class="n">max_pressure</span> <span class="o">*</span> <span class="p">(</span><span class="mi">5</span> <span class="o">/</span> <span class="mi">6</span><span class="p">),</span> <span class="n">max_pressure</span> <span class="o">*</span> <span class="p">(</span><span class="mi">5</span> <span class="o">/</span> <span class="mi">6</span><span class="p">)</span>
        <span class="n">minColor</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">upper</span> <span class="o">/</span> <span class="n">max_pressure</span><span class="p">)</span>
        <span class="n">maxColor</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">upper</span> <span class="o">/</span> <span class="n">max_pressure</span><span class="p">)</span>
        <span class="n">truncated_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">truncate_colormap</span><span class="p">(</span><span class="n">default_cmap</span><span class="p">,</span> <span class="n">minColor</span><span class="p">,</span> <span class="n">maxColor</span><span class="p">)</span>
        <span class="c1"># Normalise about new points</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span>
        <span class="c1"># Create scaled cmap</span>
        <span class="n">scaled_cmap</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">(</span><span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">truncated_map</span><span class="p">)</span>
        <span class="n">colour_cmap</span> <span class="o">=</span> <span class="n">scaled_cmap</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="n">pressure</span><span class="p">)</span>
        <span class="n">colour_cmap</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">to_hex</span><span class="p">(</span><span class="n">colour_cmap</span><span class="p">)</span>

        <span class="c1"># Plot the faces</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">colour_cmap</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot_stress_axis</span><span class="p">:</span>
            <span class="n">eigvals</span><span class="p">,</span> <span class="n">eigvecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">stress</span><span class="p">)</span>
            <span class="n">indexList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">eigvals</span><span class="p">))</span>  <span class="c1"># Abs to account for contractile forces.</span>
            <span class="n">eigvals</span> <span class="o">=</span> <span class="n">eigvals</span><span class="p">[</span><span class="n">indexList</span><span class="p">]</span>
            <span class="n">eigvecs</span> <span class="o">=</span> <span class="n">eigvecs</span><span class="p">[:,</span> <span class="n">indexList</span><span class="p">]</span>
            <span class="c1"># Make vec2 orthogonal to 1 (hack if they won&#39;t be in equilibrium...)</span>
            <span class="c1"># eigvecs[:, 1] = np.array([eigvecs[1, 0], -eigvecs[0, 0]])</span>
            <span class="n">evec1</span><span class="p">,</span> <span class="n">evec2</span> <span class="o">=</span> <span class="n">eigvecs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">eigvals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">eigvecs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">eigvals</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Get perimeter centroid</span>
            <span class="n">centroid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_centroid</span><span class="p">()</span>

            <span class="n">evec2</span> <span class="o">*=</span> <span class="n">p_axis_scale</span>
            <span class="n">evec1</span> <span class="o">*=</span> <span class="n">p_axis_scale</span>

            <span class="c1"># Principal axis</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">evec1</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">evec1</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                    <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">evec1</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">evec1</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                    <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span></div>
            <span class="c1"># Minor axis</span>
            <span class="c1"># ax.plot([centroid[0], centroid[0] + evec2[0]], [centroid[1], centroid[1] + evec2[1]],</span>
            <span class="c1">#         color=&#39;black&#39;, linewidth=2, alpha=1, zorder=12)</span>
            <span class="c1"># ax.plot([centroid[0], centroid[0] - evec2[0]], [centroid[1], centroid[1] - evec2[1]],</span>
            <span class="c1">#         color=&#39;black&#39;, linewidth=2, alpha=1, zorder=12)</span>

            <span class="c1"># Arrows</span>
            <span class="c1"># opt = {&#39;length_includes_head&#39;: True, &#39;width&#39;: .4, &#39;head_width&#39;: 2.}</span>
            <span class="c1"># if pressure &lt; 0:</span>
            <span class="c1">#     plt.arrow(centroid[0], centroid[1], evec1[0], evec1[1], alpha=1, fc=&#39;k&#39;, ec=&#39;k&#39;, zorder=12, **opt)</span>
            <span class="c1">#     plt.arrow(centroid[0], centroid[1], -evec1[0], -evec1[1], alpha=1, fc=&#39;k&#39;, ec=&#39;k&#39;, zorder=12, **opt)</span>
            <span class="c1"># else:</span>
            <span class="c1">#     plt.arrow(centroid[0] - evec1[0], centroid[1] - evec1[1], evec1[0], evec1[1],</span>
            <span class="c1">#               alpha=1, fc=&#39;k&#39;, ec=&#39;k&#39;, zorder=12, **opt)</span>
            <span class="c1">#     plt.arrow(centroid[0] + evec1[0], centroid[1] + evec1[1], -evec1[0], -evec1[1],</span>
            <span class="c1">#               alpha=1, fc=&#39;k&#39;, ec=&#39;k&#39;, zorder=12, **opt)</span>


<div class="viewcode-block" id="Cell.plot_principal_axes_of_shape"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.plot_principal_axes_of_shape">[docs]</a>    <span class="k">def</span> <span class="nf">plot_principal_axes_of_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot pricipal axes of shape</span>

<span class="sd">        :param ax:  (Default value = None)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>

        <span class="c1"># Get stress tensor</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shape_tensor</span><span class="p">()</span>

        <span class="n">eigvals</span><span class="p">,</span> <span class="n">eigvecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">indexList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">eigvals</span><span class="p">))</span>  <span class="c1"># Abs to account for contractile forces.</span>
        <span class="n">eigvals</span> <span class="o">=</span> <span class="n">eigvals</span><span class="p">[</span><span class="n">indexList</span><span class="p">]</span>
        <span class="n">eigvecs</span> <span class="o">=</span> <span class="n">eigvecs</span><span class="p">[:,</span> <span class="n">indexList</span><span class="p">]</span>
        <span class="c1"># Make vec2 orthogonal to 1 (hack if they won&#39;t be in equilibrium...)</span>
        <span class="n">evec1</span><span class="p">,</span> <span class="n">evec2</span> <span class="o">=</span> <span class="n">eigvecs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">eigvals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">eigvecs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">eigvals</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">centroid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)])</span>

        <span class="n">p_axis_scale</span> <span class="o">=</span> <span class="o">.</span><span class="mi">05</span>
        <span class="n">evec2</span> <span class="o">*=</span> <span class="n">p_axis_scale</span>
        <span class="n">evec1</span> <span class="o">*=</span> <span class="n">p_axis_scale</span>
        <span class="c1"># Lines</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">evec1</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">evec1</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">evec1</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">evec1</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span></div>


<div class="viewcode-block" id="Cell.plot_protrusion_force"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.plot_protrusion_force">[docs]</a>    <span class="k">def</span> <span class="nf">plot_protrusion_force</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">colour</span><span class="o">=</span><span class="s1">&#39;C0&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot the protrusion on the cortex</span>

<span class="sd">        :param ax:  (Default value = None)</span>
<span class="sd">        :param colour:  (Default value = &#39;C0&#39;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>

        <span class="c1"># Get the protrusion force</span>
        <span class="n">protrusion_forces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_protrusion_force</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

        <span class="c1"># Get index of force</span>
        <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span> <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">protrusion_forces</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
            <span class="c1"># Get force</span>
            <span class="n">force</span> <span class="o">=</span> <span class="n">protrusion_forces</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Get location</span>
            <span class="n">location</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>

            <span class="c1"># Plot it</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="n">location</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">location</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">force</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">force</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">scale</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colour</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cell.truncate_colormap"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.truncate_colormap">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">truncate_colormap</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="n">minval</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">maxval</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Truncate a colourmap between 2 values</span>

<span class="sd">        :param cmap: A matplotlib colourmap.</span>
<span class="sd">        :param cmap: mpl cmap</span>
<span class="sd">        :param minval:  (Default value = 0.0)  New max value for the colourmap.</span>
<span class="sd">        :param minval:  (Default value = 0.0)  float</span>
<span class="sd">        :param maxval:  (Default value = 1.0)  New min value for colourmap.</span>
<span class="sd">        :param maxval:  (Default value = 1.0)  float</span>
<span class="sd">        :param n:  (Default value = 1000)  Number of values in cmap.</span>
<span class="sd">        :param n:  (Default value = 1000)  int</span>
<span class="sd">        :return:  The truncaetd cmap</span>
<span class="sd">        :rtype:  mpl cmap</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_cmap</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">LinearSegmentedColormap</span><span class="o">.</span><span class="n">from_list</span><span class="p">(</span>
            <span class="s1">&#39;trunc(</span><span class="si">{n}</span><span class="s1">,</span><span class="si">{a:.2f}</span><span class="s1">,</span><span class="si">{b:.2f}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">cmap</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">minval</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">maxval</span><span class="p">),</span>
            <span class="n">cmap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">minval</span><span class="p">,</span> <span class="n">maxval</span><span class="p">,</span> <span class="n">n</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">new_cmap</span></div>

<div class="viewcode-block" id="Cell.make_heatmap_from_array"><a class="viewcode-back" href="../rst/cell_class.html#cell_class.Cell.make_heatmap_from_array">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">make_heatmap_from_array</span><span class="p">(</span><span class="n">input_array</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;coolwarm&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given an array of values, generate a heatmap</span>

<span class="sd">        :param input_array:  Input array of values to base the cmap on.</span>
<span class="sd">        :type input_array: list</span>
<span class="sd">        :param cmap:  (Default value = &#39;coolwarm&#39;)  Name of a Matplotlib cmap.</span>
<span class="sd">        :type cmap:  sring</span>
<span class="sd">        :return:  An rgba colourmap.</span>
<span class="sd">        :rtype:  mpl cmap</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make a heatmap</span>
        <span class="n">max_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">input_array</span><span class="p">)</span>
        <span class="c1"># Use a seismic pallette</span>
        <span class="n">cmap1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
        <span class="n">cNorm</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=-</span><span class="n">max_val</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">max_val</span><span class="p">)</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">(</span><span class="n">norm</span><span class="o">=</span><span class="n">cNorm</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap1</span><span class="p">)</span>
        <span class="n">colour_cmap</span> <span class="o">=</span> <span class="n">cmap</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="n">input_array</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">colour_cmap</span></div></div>

<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Alexander Nestor-Bergmann.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>